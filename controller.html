<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hydrogen Simulation Controller</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #eee;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
            color: #4ecca3;
            font-size: 2rem;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
        }

        .card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .card h2 {
            color: #4ecca3;
            margin-bottom: 15px;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .card h3 {
            color: #888;
            margin: 15px 0 10px 0;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .card h2 .icon {
            font-size: 1.4rem;
        }

        /* Parameter inputs */
        .param-group {
            margin-bottom: 12px;
        }

        .param-group label {
            display: block;
            margin-bottom: 4px;
            color: #aaa;
            font-size: 0.85rem;
        }

        .param-group input {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.3);
            color: #fff;
            font-size: 0.95rem;
        }

        .param-group input:focus {
            outline: none;
            border-color: #4ecca3;
        }

        .param-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .param-row-3 {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 10px;
        }

        /* Buttons */
        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: 6px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            justify-content: center;
        }

        .btn-primary {
            background: #4ecca3;
            color: #1a1a2e;
            font-weight: 600;
        }

        .btn-primary:hover {
            background: #3db892;
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .btn-blender {
            background: #ea7600;
            color: #fff;
        }

        .btn-blender:hover {
            background: #ff8c1a;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-group {
            display: flex;
            gap: 8px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .btn-group .btn {
            flex: 1 1 auto;
            min-width: 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-size: 0.85em;
            padding: 8px 10px;
        }

        /* Network visualization */
        .network-canvas {
            width: 100%;
            height: 200px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            position: relative;
            overflow: hidden;
        }

        .node {
            position: absolute;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.7rem;
            cursor: move;
            transition: transform 0.1s;
        }

        .node.producer {
            clip-path: polygon(50% 0%, 0% 100%, 100% 100%);
            background: #4ecca3;
            color: #1a1a2e;
        }

        .node.converter {
            background: #f0c040;
            color: #1a1a2e;
            border-radius: 4px;
        }

        .node.consumer {
            background: #e74c3c;
            color: #fff;
            border-radius: 50%;
        }

        .node.storage {
            background: #9b59b6;
            color: #fff;
            border-radius: 8px;
        }

        .node:hover {
            transform: scale(1.1);
        }

        /* Results */
        .results-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .results-grid-3 {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        .result-item {
            background: rgba(0, 0, 0, 0.2);
            padding: 10px;
            border-radius: 6px;
        }

        .result-item .label {
            font-size: 0.75rem;
            color: #888;
            margin-bottom: 2px;
        }

        .result-item .value {
            font-size: 1.1rem;
            font-weight: bold;
            color: #4ecca3;
        }

        .result-item .value.negative {
            color: #e74c3c;
        }

        .result-item .value.positive {
            color: #4ecca3;
        }

        .result-item .unit {
            font-size: 0.75rem;
            color: #888;
        }

        /* Tranches table */
        .tranches-table {
            width: 100%;
            margin-top: 10px;
            font-size: 0.8rem;
        }

        .tranches-table th, .tranches-table td {
            padding: 6px 8px;
            text-align: left;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .tranches-table th {
            color: #888;
            font-weight: normal;
        }

        .tranches-table .utilization {
            width: 80px;
        }

        .utilization-bar {
            height: 6px;
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
            overflow: hidden;
        }

        .utilization-fill {
            height: 100%;
            background: #4ecca3;
            transition: width 0.3s;
        }

        /* Status */
        .status {
            padding: 10px;
            border-radius: 6px;
            margin-top: 15px;
            font-size: 0.85rem;
        }

        .status.success {
            background: rgba(78, 204, 163, 0.2);
            border: 1px solid #4ecca3;
        }

        .status.error {
            background: rgba(231, 76, 60, 0.2);
            border: 1px solid #e74c3c;
        }

        .status.info {
            background: rgba(52, 152, 219, 0.2);
            border: 1px solid #3498db;
        }

        /* Loading spinner */
        .spinner {
            width: 20px;
            height: 20px;
            border: 2px solid transparent;
            border-top-color: currentColor;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Footer */
        .footer {
            text-align: center;
            margin-top: 30px;
            color: #666;
            font-size: 0.9rem;
        }

        /* Card spanning full width */
        .card-wide {
            grid-column: 1 / -1;
        }

        /* Top row: Network + Node Management side by side */
        .top-row {
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: 20px;
            grid-column: 1 / -1;
        }

        @media (max-width: 1000px) {
            .top-row {
                grid-template-columns: 1fr;
            }
        }

        /* Modal styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: #1a1a2e;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 25px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-content h3 {
            color: #4ecca3;
            margin-bottom: 20px;
        }

        .modal-close {
            float: right;
            background: none;
            border: none;
            color: #888;
            font-size: 1.5rem;
            cursor: pointer;
        }

        .modal-close:hover {
            color: #fff;
        }

        /* Node item in list */
        .node-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 8px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
            margin-bottom: 6px;
        }

        .node-item .node-name {
            font-weight: bold;
            color: #4ecca3;
            flex: 1;
            font-size: 0.85rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .node-item .node-type {
            font-size: 0.65rem;
            color: #666;
            white-space: nowrap;
        }

        .btn-small {
            padding: 2px 6px;
            font-size: 0.65rem;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            flex-shrink: 0;
        }

        .btn-edit {
            background: rgba(78, 204, 163, 0.3);
            color: #4ecca3;
        }

        .btn-edit:hover {
            background: rgba(78, 204, 163, 0.5);
        }

        .btn-delete {
            background: rgba(231, 76, 60, 0.3);
            color: #e74c3c;
        }

        .btn-delete:hover {
            background: rgba(231, 76, 60, 0.5);
        }

        /* Node management grid */
        .node-columns {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 12px;
        }

        @media (max-width: 1400px) {
            .node-columns {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        @media (max-width: 900px) {
            .node-columns {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        .node-column h3 {
            color: #888;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .node-column h3 .count {
            background: rgba(78, 204, 163, 0.3);
            padding: 1px 6px;
            border-radius: 10px;
            font-size: 0.65rem;
            color: #4ecca3;
        }

        .node-list {
            min-height: 60px;
            margin-bottom: 8px;
        }

        .node-list:empty::after {
            content: 'None';
            color: #555;
            font-size: 0.75rem;
            font-style: italic;
        }

        /* Clickable edges in network view */
        .pipes-svg line {
            cursor: pointer;
            stroke-width: 4;
            transition: stroke-width 0.2s, opacity 0.2s;
        }

        .pipes-svg line:hover {
            stroke-width: 8;
        }

        .pipes-svg line.disabled {
            stroke-dasharray: 4 4;
            opacity: 0.4;
        }

        /* Connection drag target highlights */
        .node.valid-target {
            box-shadow: 0 0 0 3px #4ecca3, 0 0 15px rgba(78, 204, 163, 0.6);
            animation: pulse-valid 1s infinite;
        }

        .node.invalid-target {
            opacity: 0.4;
        }

        @keyframes pulse-valid {
            0%, 100% { box-shadow: 0 0 0 3px #4ecca3, 0 0 15px rgba(78, 204, 163, 0.6); }
            50% { box-shadow: 0 0 0 5px #4ecca3, 0 0 25px rgba(78, 204, 163, 0.8); }
        }

        /* Hint text for network canvas */
        .network-hint {
            position: absolute;
            bottom: 5px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.7rem;
            color: #666;
            pointer-events: none;
        }

        /* Network controls */
        .network-controls {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            margin-left: auto;
            font-size: 0.9rem;
        }

        .btn-icon {
            width: 28px;
            height: 28px;
            border: none;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            cursor: pointer;
            font-size: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }

        .btn-icon:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .zoom-level {
            font-size: 0.75rem;
            color: #888;
            min-width: 40px;
            text-align: center;
        }

        /* Network canvas wrapper for zoom/scroll */
        .network-canvas-wrapper {
            width: 100%;
            height: 450px;
            min-height: 300px;
            max-height: 600px;
            overflow: hidden;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.3);
            position: relative;
        }

        .network-canvas {
            width: 100%;
            height: 100%;
            position: relative;
            transition: transform 0.2s;
        }

        /* Fullscreen mode */
        #network-card.fullscreen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 1000;
            margin: 0;
            border-radius: 0;
            max-width: none;
            display: flex;
            flex-direction: column;
        }

        #network-card.fullscreen .network-canvas-wrapper {
            flex: 1;
            height: auto !important;
            min-height: 0 !important;
            max-height: none !important;
        }

        #network-card.fullscreen .network-hint {
            font-size: 0.85rem;
        }

        #network-card.fullscreen #fullscreen-btn {
            background: rgba(78, 204, 163, 0.3);
        }

        /* Fullscreen overlay background */
        .fullscreen-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            z-index: 999;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Hydrogen Simulation Controller</h1>

        <div class="grid">
            <!-- Top Row: Network + Node Management -->
            <div class="top-row">
                <!-- Network Card -->
                <div class="card" id="network-card">
                <h2>
                    <span class="icon">ðŸ”—</span> Network Topology
                    <div class="network-controls">
                        <button class="btn-icon" onclick="zoomIn()" title="Zoom In">+</button>
                        <span class="zoom-level" id="zoom-level">100%</span>
                        <button class="btn-icon" onclick="zoomOut()" title="Zoom Out">âˆ’</button>
                        <button class="btn-icon" onclick="resetZoom()" title="Reset Zoom">âŸ²</button>
                        <button class="btn-icon" onclick="toggleFullscreen()" title="Fullscreen" id="fullscreen-btn">â›¶</button>
                    </div>
                </h2>

                <div class="network-canvas-wrapper" id="network-canvas-wrapper">
                    <div class="network-canvas" id="network-canvas" style="transform-origin: center center;">
                        <svg id="pipes-svg" style="position:absolute;width:100%;height:100%;pointer-events:none;"></svg>
                        <div class="network-hint">Drag to move â€¢ Ctrl+Scroll to zoom â€¢ Middle-click drag to pan â€¢ Ctrl+Drag to connect</div>
                    </div>
                </div>

                <div class="btn-group" style="margin-top:10px;">
                    <button class="btn btn-secondary" onclick="saveLayout()" title="Export Registry">ðŸ’¾ Export</button>
                    <button class="btn btn-secondary" onclick="document.getElementById('layout-file-input').click()" title="Import Registry">ðŸ“‚ Import</button>
                    <input type="file" id="layout-file-input" accept=".json" style="display:none;" onchange="loadLayoutFile(event)">
                    <button class="btn btn-secondary" onclick="regenerateConnections()" title="Reset Connections">ðŸ”„ Reset</button>
                </div>

                <div id="network-status"></div>
            </div>

            <!-- Node Management Card -->
            <div class="card">
                <h2><span class="icon">âš™</span> Node Management</h2>

                <!-- Preset Loader -->
                <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 15px; padding-bottom: 15px; border-bottom: 1px solid #333;">
                    <label style="color: #888; font-size: 0.85rem;">Load Preset:</label>
                    <select id="preset-select" style="flex: 1; padding: 8px; background: #1a1a2e; border: 1px solid #333; border-radius: 4px; color: #eee;">
                        <option value="">-- Select Preset --</option>
                    </select>
                    <button class="btn btn-secondary" onclick="loadSelectedPreset()" style="padding: 8px 16px;">
                        Load
                    </button>
                </div>

                <div class="node-columns">
                    <!-- Generators Column -->
                    <div class="node-column">
                        <h3>Generators <span class="count" id="gen-count">0</span></h3>
                        <div class="node-list" id="generators-list"></div>
                        <button class="btn btn-secondary" onclick="openAddNodeModal('generator')" style="width:100%;">
                            + Add Generator
                        </button>
                    </div>

                    <!-- Transformers Column -->
                    <div class="node-column">
                        <h3>Transformers <span class="count" id="trans-count">0</span></h3>
                        <div class="node-list" id="transformers-list"></div>
                        <button class="btn btn-secondary" onclick="openAddNodeModal('transformer')" style="width:100%;">
                            + Add Transformer
                        </button>
                    </div>

                    <!-- Consumers Column -->
                    <div class="node-column">
                        <h3>Consumers <span class="count" id="cons-count">0</span></h3>
                        <div class="node-list" id="consumers-list"></div>
                        <button class="btn btn-secondary" onclick="openAddNodeModal('consumer')" style="width:100%;">
                            + Add Consumer
                        </button>
                    </div>

                    <!-- Batteries Column -->
                    <div class="node-column">
                        <h3>Batteries <span class="count" id="batt-count">0</span></h3>
                        <div class="node-list" id="batteries-list"></div>
                        <button class="btn btn-secondary" onclick="openAddNodeModal('battery')" style="width:100%;">
                            + Add Battery
                        </button>
                    </div>

                    <!-- H2 Storage Column -->
                    <div class="node-column">
                        <h3>H2 Storage <span class="count" id="h2s-count">0</span></h3>
                        <div class="node-list" id="h2storage-list"></div>
                        <button class="btn btn-secondary" onclick="openAddNodeModal('h2_storage')" style="width:100%;">
                            + Add H2 Storage
                        </button>
                    </div>
                </div>

                <div id="node-status" style="margin-top:15px;"></div>
            </div>
            </div><!-- End top-row -->

            <!-- Blender Card -->
            <div class="card">
                <h2><span class="icon">ðŸŽ¨</span> Blender Integration</h2>

                <p style="color: #888; margin-bottom: 15px; font-size: 0.85rem;">
                    Sync node positions between this controller and Blender.
                </p>

                <div class="btn-group">
                    <button class="btn btn-blender" onclick="launchBlender()">
                        ðŸš€ Launch Blender
                    </button>
                </div>

                <div class="btn-group">
                    <button class="btn btn-secondary" onclick="exportToBlender()">
                        ðŸ“¤ Export
                    </button>
                    <button class="btn btn-secondary" onclick="syncFromBlender()">
                        ðŸ“¥ Sync
                    </button>
                </div>

                <div id="blender-status"></div>

                <div style="margin-top: 15px; padding: 8px; background: rgba(0,0,0,0.2); border-radius: 6px; font-size: 0.8rem; color: #888;">
                    <strong>In Blender:</strong> <code style="color: #4ecca3;">sync_from_blender()</code>
                </div>
            </div>

            <!-- Parameters Card -->
            <div class="card">
                <h2><span class="icon">âš¡</span> Production & Costs</h2>

                <div class="param-group">
                    <label>Simulation Periods (hours)</label>
                    <input type="number" id="periods" value="24" min="1" max="168">
                </div>

                <h3>Alpha - Electricity Producer</h3>
                <div class="param-row">
                    <div class="param-group">
                        <label>Capacity (kW)</label>
                        <input type="number" id="alpha_capacity" value="100" min="0" step="10">
                    </div>
                    <div class="param-group">
                        <label>Cost (ct/kWh)</label>
                        <input type="number" id="alpha_cost" value="8" min="0" step="0.5">
                    </div>
                </div>

                <h3>Bravo - Electrolyzer</h3>
                <div class="param-row-3">
                    <div class="param-group">
                        <label>Capacity (kW)</label>
                        <input type="number" id="bravo_capacity" value="50" min="0" step="10">
                    </div>
                    <div class="param-group">
                        <label>Efficiency (%)</label>
                        <input type="number" id="bravo_efficiency" value="70" min="0" max="100" step="5">
                    </div>
                    <div class="param-group">
                        <label>Cost (ct/kWh)</label>
                        <input type="number" id="bravo_cost" value="1.5" min="0" step="0.1">
                    </div>
                </div>

                <h3>Grid Backup</h3>
                <div class="param-group">
                    <label>Grid Electricity Cost (ct/kWh)</label>
                    <input type="number" id="grid_cost" value="15" min="0" step="1">
                </div>

                <div class="btn-group">
                    <button class="btn btn-primary" onclick="runSimulation()">
                        <span id="sim-icon">â–¶</span> Run Simulation
                    </button>
                    <button class="btn btn-secondary" onclick="runDetailedSimulation()">
                        <span id="log-icon">ðŸ“‹</span> Detailed Log
                    </button>
                </div>

                <div id="sim-status"></div>
            </div>

            <!-- Consumer Utility Card (Dynamic) -->
            <div class="card">
                <h2><span class="icon">ðŸ“ˆ</span> Consumer Utility Functions</h2>
                <div id="consumer-utility-container">
                    <p style="color:#666">Loading consumers...</p>
                </div>
            </div>

            <!-- Economic Results Card -->
            <div class="card">
                <h2><span class="icon">ðŸ’°</span> Economic Results</h2>

                <div class="results-grid-3">
                    <div class="result-item">
                        <div class="label">Total Costs</div>
                        <div class="value negative" id="res-costs">--</div>
                    </div>
                    <div class="result-item">
                        <div class="label">Total Utility</div>
                        <div class="value positive" id="res-utility">--</div>
                    </div>
                    <div class="result-item">
                        <div class="label">Net Welfare</div>
                        <div class="value" id="res-welfare">--</div>
                    </div>
                </div>

                <h3>Production</h3>
                <div class="results-grid">
                    <div class="result-item">
                        <div class="label">Alpha Production</div>
                        <div class="value" id="res-alpha">--</div>
                    </div>
                    <div class="result-item">
                        <div class="label">Grid Supply</div>
                        <div class="value" id="res-grid">--</div>
                    </div>
                </div>

                <h3>Consumption by Consumer</h3>
                <div class="results-grid-3">
                    <div class="result-item">
                        <div class="label">Charlie (H2)</div>
                        <div class="value" id="res-charlie">--</div>
                    </div>
                    <div class="result-item">
                        <div class="label">Delta (Elec)</div>
                        <div class="value" id="res-delta">--</div>
                    </div>
                    <div class="result-item">
                        <div class="label">Echo (Bundles)</div>
                        <div class="value" id="res-echo-bundles">--</div>
                    </div>
                </div>

                <h3>Totals & Echo Breakdown</h3>
                <div class="results-grid">
                    <div class="result-item">
                        <div class="label">Total H2 Consumed</div>
                        <div class="value" id="res-total-h2">--</div>
                    </div>
                    <div class="result-item">
                        <div class="label">Total Elec Consumed</div>
                        <div class="value" id="res-total-elec">--</div>
                    </div>
                </div>
                <div class="results-grid" id="echo-breakdown" style="margin-top:8px;">
                    <div class="result-item">
                        <div class="label">Echo H2</div>
                        <div class="value" id="res-echo-h2">--</div>
                    </div>
                    <div class="result-item">
                        <div class="label">Echo Elec</div>
                        <div class="value" id="res-echo-elec">--</div>
                    </div>
                </div>

                <h3>Marginal Cost</h3>
                <div class="result-item">
                    <div class="label">Hydrogen Production Cost</div>
                    <div class="value" id="res-h2-cost">--</div>
                </div>

                <div id="results-status"></div>
            </div>

            <!-- Time Series Charts Card -->
            <div class="card card-wide">
                <h2><span class="icon">ðŸ“ˆ</span> Time Series Analysis</h2>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                    <div>
                        <div id="chart-electricity" style="width:100%;height:280px;"></div>
                    </div>
                    <div>
                        <div id="chart-hydrogen" style="width:100%;height:280px;"></div>
                    </div>
                </div>

                <div style="margin-top: 15px;">
                    <div id="chart-stacked" style="width:100%;height:300px;"></div>
                </div>

                <div id="storage-charts-section" style="margin-top: 15px; display: none;">
                    <h3 style="color: #4ecca3; margin-bottom: 10px; font-size: 14px;">Storage State</h3>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; overflow: hidden;">
                        <div id="chart-battery" style="width:100%;height:250px;overflow:hidden;"></div>
                        <div id="chart-h2storage" style="width:100%;height:250px;overflow:hidden;"></div>
                    </div>
                </div>
            </div>

            <!-- Detailed Simulation Log Card -->
            <div class="card card-wide" id="detailed-log-card" style="display: none;">
                <h2><span class="icon">ðŸ“‹</span> Detailed Simulation Log</h2>
                <div style="display: flex; gap: 10px; margin-bottom: 15px; align-items: center;">
                    <label style="color: #888; font-size: 0.85rem;">View timestep:</label>
                    <input type="range" id="log-timestep-slider" min="0" max="23" value="0"
                           style="flex: 1;" oninput="updateLogTimestep(this.value)">
                    <span id="log-timestep-value" style="color: #4ecca3; font-weight: bold; min-width: 60px;">Hour 0</span>
                    <button class="btn btn-secondary" onclick="exportLogCSV()" style="padding: 6px 12px; font-size: 0.8rem;">
                        Export CSV
                    </button>
                </div>

                <div id="log-timestep-content" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 15px;">
                    <!-- Generator Section -->
                    <div class="log-section" style="background: #1a1a2e; padding: 12px; border-radius: 8px; border-left: 3px solid #f1c40f;">
                        <h4 style="color: #f1c40f; margin: 0 0 10px 0; font-size: 0.9rem;">Generators</h4>
                        <div id="log-generators" style="font-family: monospace; font-size: 0.8rem; color: #ccc;"></div>
                    </div>

                    <!-- Transformer Section -->
                    <div class="log-section" style="background: #1a1a2e; padding: 12px; border-radius: 8px; border-left: 3px solid #9b59b6;">
                        <h4 style="color: #9b59b6; margin: 0 0 10px 0; font-size: 0.9rem;">Transformers</h4>
                        <div id="log-transformers" style="font-family: monospace; font-size: 0.8rem; color: #ccc;"></div>
                    </div>

                    <!-- Consumer Section -->
                    <div class="log-section" style="background: #1a1a2e; padding: 12px; border-radius: 8px; border-left: 3px solid #27ae60;">
                        <h4 style="color: #27ae60; margin: 0 0 10px 0; font-size: 0.9rem;">Consumers</h4>
                        <div id="log-consumers" style="font-family: monospace; font-size: 0.8rem; color: #ccc;"></div>
                    </div>

                    <!-- Storage Section -->
                    <div class="log-section" style="background: #1a1a2e; padding: 12px; border-radius: 8px; border-left: 3px solid #3498db;">
                        <h4 style="color: #3498db; margin: 0 0 10px 0; font-size: 0.9rem;">Storage</h4>
                        <div id="log-storage" style="font-family: monospace; font-size: 0.8rem; color: #ccc;"></div>
                    </div>
                </div>

                <!-- Full Log Table (collapsible) -->
                <details style="margin-top: 15px;">
                    <summary style="cursor: pointer; color: #4ecca3; font-weight: bold; padding: 8px 0;">
                        Full Timestep Table
                    </summary>
                    <div style="max-height: 400px; overflow-y: auto; margin-top: 10px;">
                        <table id="log-full-table" style="width: 100%; border-collapse: collapse; font-size: 0.75rem;">
                            <thead id="log-table-head" style="position: sticky; top: 0; background: #16213e;"></thead>
                            <tbody id="log-table-body"></tbody>
                        </table>
                    </div>
                </details>

                <div id="log-status" style="margin-top: 10px;"></div>
            </div>

        </div>

        <!-- Add/Edit Node Modal -->
        <div id="node-modal" class="modal">
            <div class="modal-content">
                <button class="modal-close" onclick="closeNodeModal()">&times;</button>
                <h3 id="modal-title">Add Node</h3>

                <div class="param-group">
                    <label>Name</label>
                    <input type="text" id="node-name" placeholder="Enter node name">
                </div>

                <!-- Generator fields -->
                <div id="generator-fields" style="display:none;">
                    <div class="param-row">
                        <div class="param-group">
                            <label>Capacity (kW)</label>
                            <input type="number" id="gen-capacity" value="100" min="0" step="10">
                        </div>
                        <div class="param-group">
                            <label>Cost (ct/kWh)</label>
                            <input type="number" id="gen-cost" value="8" min="0" step="0.5">
                        </div>
                    </div>
                    <div class="param-group">
                        <label>Profile Type</label>
                        <select id="gen-profile">
                            <option value="solar">Solar (peaks midday)</option>
                            <option value="wind">Wind (variable)</option>
                            <option value="flat">Flat (constant)</option>
                        </select>
                    </div>
                </div>

                <!-- Transformer fields -->
                <div id="transformer-fields" style="display:none;">
                    <div class="param-row-3">
                        <div class="param-group">
                            <label>Capacity (kW)</label>
                            <input type="number" id="trans-capacity" value="50" min="0" step="10">
                        </div>
                        <div class="param-group">
                            <label>Efficiency (%)</label>
                            <input type="number" id="trans-efficiency" value="70" min="0" max="100" step="5">
                        </div>
                        <div class="param-group">
                            <label>Cost (ct/kWh)</label>
                            <input type="number" id="trans-cost" value="1.5" min="0" step="0.1">
                        </div>
                    </div>
                </div>

                <!-- Consumer fields -->
                <div id="consumer-fields" style="display:none;">
                    <div class="param-group">
                        <label>Consumer Type</label>
                        <select id="cons-type" onchange="toggleConsumerParams()">
                            <option value="logarithmic_electricity">Electricity (Logarithmic)</option>
                            <option value="logarithmic_hydrogen">Hydrogen (Logarithmic)</option>
                            <option value="cobb_douglas">Combined (Cobb-Douglas)</option>
                        </select>
                    </div>

                    <!-- Logarithmic params -->
                    <div id="log-params">
                        <p style="color:#666;font-size:0.75rem;margin-bottom:8px;">U(x) = scale Ã— ln(1 + x/shape)</p>
                        <div class="param-row-3">
                            <div class="param-group">
                                <label>Scale (a)</label>
                                <input type="number" id="cons-log-scale" value="30" min="1" step="1">
                            </div>
                            <div class="param-group">
                                <label>Shape (b)</label>
                                <input type="number" id="cons-log-shape" value="5" min="0.1" step="0.5">
                            </div>
                            <div class="param-group">
                                <label>Max Qty</label>
                                <input type="number" id="cons-log-max" value="25" min="1" step="5">
                            </div>
                        </div>
                    </div>

                    <!-- Cobb-Douglas params -->
                    <div id="cd-params" style="display:none;">
                        <p style="color:#666;font-size:0.75rem;margin-bottom:8px;">U(h,e) = A Ã— h<sup>Î±</sup> Ã— e<sup>Î²</sup></p>
                        <div class="param-row-3">
                            <div class="param-group">
                                <label>Scale (A)</label>
                                <input type="number" id="cons-cd-A" value="15" min="0.1" step="1">
                            </div>
                            <div class="param-group">
                                <label>H2 exp (Î±)</label>
                                <input type="number" id="cons-cd-alpha" value="0.4" min="0.01" max="1" step="0.05">
                            </div>
                            <div class="param-group">
                                <label>Elec exp (Î²)</label>
                                <input type="number" id="cons-cd-beta" value="0.6" min="0.01" max="1" step="0.05">
                            </div>
                        </div>
                        <div class="param-row-3">
                            <div class="param-group">
                                <label>H2/bundle (kg)</label>
                                <input type="number" id="cons-cd-h" value="1" min="0.1" step="0.5">
                            </div>
                            <div class="param-group">
                                <label>Elec/bundle (kWh)</label>
                                <input type="number" id="cons-cd-e" value="3" min="0.1" step="0.5">
                            </div>
                            <div class="param-group">
                                <label>Max bundles</label>
                                <input type="number" id="cons-cd-max" value="15" min="1" step="1">
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Battery fields -->
                <div id="battery-fields" style="display:none;">
                    <div class="param-row">
                        <div class="param-group">
                            <label>Capacity (kWh)</label>
                            <input type="number" id="batt-capacity" value="100" min="0" step="10">
                        </div>
                        <div class="param-group">
                            <label>Cost (ct/kWh)</label>
                            <input type="number" id="batt-cost" value="1" min="0" step="0.1">
                        </div>
                    </div>
                    <div class="param-row">
                        <div class="param-group">
                            <label>Charge Rate (kW)</label>
                            <input type="number" id="batt-charge-rate" value="50" min="0" step="5">
                        </div>
                        <div class="param-group">
                            <label>Discharge Rate (kW)</label>
                            <input type="number" id="batt-discharge-rate" value="50" min="0" step="5">
                        </div>
                    </div>
                    <div class="param-row-3">
                        <div class="param-group">
                            <label>Efficiency In (%)</label>
                            <input type="number" id="batt-eff-in" value="95" min="0" max="100" step="1">
                        </div>
                        <div class="param-group">
                            <label>Efficiency Out (%)</label>
                            <input type="number" id="batt-eff-out" value="95" min="0" max="100" step="1">
                        </div>
                        <div class="param-group">
                            <label>Loss Rate (%/h)</label>
                            <input type="number" id="batt-loss" value="0.02" min="0" max="10" step="0.01">
                        </div>
                    </div>
                    <div class="param-row">
                        <div class="param-group">
                            <label>Initial Level (%)</label>
                            <input type="number" id="batt-initial" value="50" min="0" max="100" step="5">
                        </div>
                        <div class="param-group">
                            <label>Min Level (%)</label>
                            <input type="number" id="batt-min" value="10" min="0" max="100" step="5">
                        </div>
                    </div>
                </div>

                <!-- H2 Storage fields -->
                <div id="h2storage-fields" style="display:none;">
                    <div class="param-row">
                        <div class="param-group">
                            <label>Capacity (kg)</label>
                            <input type="number" id="h2s-capacity" value="50" min="0" step="10">
                        </div>
                        <div class="param-group">
                            <label>Cost (ct/kg)</label>
                            <input type="number" id="h2s-cost" value="0.5" min="0" step="0.1">
                        </div>
                    </div>
                    <div class="param-row">
                        <div class="param-group">
                            <label>Injection Rate (kg/h)</label>
                            <input type="number" id="h2s-injection-rate" value="10" min="0" step="1">
                        </div>
                        <div class="param-group">
                            <label>Withdrawal Rate (kg/h)</label>
                            <input type="number" id="h2s-withdrawal-rate" value="10" min="0" step="1">
                        </div>
                    </div>
                    <div class="param-row-3">
                        <div class="param-group">
                            <label>Efficiency In (%)</label>
                            <input type="number" id="h2s-eff-in" value="95" min="0" max="100" step="1">
                        </div>
                        <div class="param-group">
                            <label>Efficiency Out (%)</label>
                            <input type="number" id="h2s-eff-out" value="99" min="0" max="100" step="1">
                        </div>
                        <div class="param-group">
                            <label>Loss Rate (%/h)</label>
                            <input type="number" id="h2s-loss" value="0.01" min="0" max="10" step="0.01">
                        </div>
                    </div>
                    <div class="param-group">
                        <label>Initial Level (%)</label>
                        <input type="number" id="h2s-initial" value="50" min="0" max="100" step="5">
                    </div>
                </div>

                <div class="btn-group" style="margin-top:20px;">
                    <button class="btn btn-secondary" onclick="closeNodeModal()">Cancel</button>
                    <button class="btn btn-primary" onclick="saveNode()">Save</button>
                </div>
            </div>
        </div>

        <div class="footer">
            Hydrogen System Simulation | Logarithmic & Cobb-Douglas Utility Functions
        </div>
    </div>

    <script>
        const API_BASE = '';

        // Node positions (normalized 0-1) - populated by loadNodes()
        let nodes = {};

        // Edges - populated by loadNodes()
        let edges = [];

        // Note: Initialization moved to end of script (loadConfig, loadNodes, renderNetwork)

        // Load configuration
        async function loadConfig() {
            try {
                const res = await fetch(`${API_BASE}/api/config`);
                const config = await res.json();

                // Basic parameters
                document.getElementById('periods').value = config.periods;
                document.getElementById('alpha_capacity').value = config.alpha_capacity;
                document.getElementById('alpha_cost').value = config.alpha_cost;
                document.getElementById('bravo_capacity').value = config.bravo_capacity;
                document.getElementById('bravo_efficiency').value = config.bravo_efficiency * 100;
                document.getElementById('bravo_cost').value = config.bravo_cost;
                document.getElementById('grid_cost').value = config.grid_cost;

                // Consumer utilities are populated via renderConsumerUtilityForms() from node registry
            } catch (e) {
                console.error('Failed to load config:', e);
            }
        }

        // Load network
        async function loadNetwork() {
            try {
                const res = await fetch(`${API_BASE}/api/network`);
                const network = await res.json();

                if (network.nodes) {
                    network.nodes.forEach(node => {
                        if (nodes[node.name]) {
                            nodes[node.name].x = (node.position[0] + 3) / 6;
                            nodes[node.name].y = 1 - (node.position[1] + 3) / 6;
                        }
                    });
                    renderNetwork();
                }
            } catch (e) {
                console.error('Failed to load network:', e);
            }
        }

        // Render network visualization
        function renderNetwork() {
            const canvas = document.getElementById('network-canvas');
            const svg = document.getElementById('pipes-svg');
            const rect = canvas.getBoundingClientRect();
            const width = rect.width;
            const height = rect.height;

            canvas.querySelectorAll('.node').forEach(n => n.remove());
            svg.innerHTML = '';
            svg.style.pointerEvents = 'auto';  // Enable click events on SVG

            // Helper function to convert normalized world coords to screen coords
            // Applies pan offset and zoom
            function toScreenX(normX) {
                // World to screen: screen = (world - 0.5 - panX) * zoom + 0.5
                return ((normX - 0.5 - panX) * currentZoom + 0.5) * width;
            }
            function toScreenY(normY) {
                return ((normY - 0.5 - panY) * currentZoom + 0.5) * height;
            }

            // Scale node size based on zoom
            const nodeSize = Math.max(20, Math.min(80, 50 * currentZoom));
            const halfNode = nodeSize / 2;
            const strokeWidth = Math.max(2, Math.min(6, 4 * currentZoom));
            const fontSize = Math.max(8, Math.min(16, 12 * currentZoom));

            // Draw pipes (edges)
            edges.forEach(edge => {
                const source = nodes[edge.source];
                const target = nodes[edge.target];
                if (!source || !target) return;  // Skip if nodes not yet loaded

                const x1 = toScreenX(source.x);
                const y1 = toScreenY(source.y);
                const x2 = toScreenX(target.x);
                const y2 = toScreenY(target.y);

                const isEnabled = edge.enabled !== false;

                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', x1);
                line.setAttribute('y1', y1);
                line.setAttribute('x2', x2);
                line.setAttribute('y2', y2);
                line.setAttribute('stroke', edge.carrier === 'electricity' ? '#f0c040' : '#3498db');
                line.setAttribute('stroke-width', strokeWidth);
                line.setAttribute('stroke-linecap', 'round');

                // Visual distinction for disabled connections
                if (!isEnabled) {
                    line.setAttribute('stroke-dasharray', '6 4');
                    line.setAttribute('opacity', '0.4');
                }

                // Make lines clickable for toggling
                line.style.cursor = 'pointer';
                line.dataset.source = edge.source;
                line.dataset.target = edge.target;
                line.dataset.carrier = edge.carrier;
                line.addEventListener('click', handleEdgeClick);

                svg.appendChild(line);
            });

            // Draw nodes
            Object.entries(nodes).forEach(([name, node]) => {
                const el = document.createElement('div');
                el.className = `node ${node.type}`;
                el.textContent = name;
                el.style.left = `${toScreenX(node.x) - halfNode}px`;
                el.style.top = `${toScreenY(node.y) - halfNode}px`;
                el.style.width = `${nodeSize}px`;
                el.style.height = `${nodeSize}px`;
                el.style.fontSize = `${fontSize}px`;
                el.addEventListener('mousedown', startDrag);
                el.dataset.name = name;
                canvas.appendChild(el);
            });
        }

        // Handle clicking on an edge to delete it
        function handleEdgeClick(e) {
            e.stopPropagation();
            const source = e.target.dataset.source;
            const target = e.target.dataset.target;
            const carrier = e.target.dataset.carrier;
            deleteConnection(source, target, carrier);
        }

        // Drag functionality
        let dragging = null;
        let dragOffset = { x: 0, y: 0 };

        // Connection drag state (Ctrl+drag)
        let connectionDrag = {
            active: false,
            sourceNode: null,
            sourceName: null,
            tempLine: null
        };

        function startDrag(e) {
            // If Ctrl is held, start connection drag instead of position drag
            if (e.ctrlKey || e.metaKey) {
                startConnectionDrag(e);
                return;
            }

            dragging = e.target;
            const rect = dragging.getBoundingClientRect();
            dragOffset.x = e.clientX - rect.left - 25;
            dragOffset.y = e.clientY - rect.top - 25;
            document.addEventListener('mousemove', doDrag);
            document.addEventListener('mouseup', stopDrag);
        }

        function doDrag(e) {
            if (!dragging) return;
            const canvas = document.getElementById('network-canvas');
            const rect = canvas.getBoundingClientRect();

            // Get mouse position relative to canvas as normalized (0-1)
            const screenNormX = (e.clientX - rect.left) / rect.width;
            const screenNormY = (e.clientY - rect.top) / rect.height;

            // Convert from screen to world coordinates
            // Screen: screenNorm = (world - 0.5 - pan) * zoom + 0.5
            // World: world = (screenNorm - 0.5) / zoom + 0.5 + pan
            let normX = (screenNormX - 0.5) / currentZoom + 0.5 + panX;
            let normY = (screenNormY - 0.5) / currentZoom + 0.5 + panY;

            // Clamp to valid range
            normX = Math.max(0.05, Math.min(0.95, normX));
            normY = Math.max(0.05, Math.min(0.95, normY));

            const name = dragging.dataset.name;
            nodes[name].x = normX;
            nodes[name].y = normY;
            renderNetwork();
        }

        function stopDrag() {
            if (dragging) updateNetworkPositions();
            dragging = null;
            document.removeEventListener('mousemove', doDrag);
            document.removeEventListener('mouseup', stopDrag);
        }

        // =========================================
        // Connection Drag (Ctrl+Drag) Functions
        // =========================================

        // Connection rules: returns { valid: bool, carrier: string, reason: string }
        function getConnectionValidity(sourceType, targetType, sourceCarrier, targetCarrier) {
            // Consumers can't be sources
            if (sourceType === 'consumer') {
                return { valid: false, carrier: null, reason: 'Consumers cannot be connection sources' };
            }

            // Producers can't be targets
            if (targetType === 'producer') {
                return { valid: false, carrier: null, reason: 'Producers cannot be connection targets' };
            }

            // Same node type (except storage) - invalid
            if (sourceType === targetType && sourceType !== 'storage') {
                return { valid: false, carrier: null, reason: 'Cannot connect same node types' };
            }

            // Producer -> Converter: electricity
            if (sourceType === 'producer' && targetType === 'converter') {
                return { valid: true, carrier: 'electricity', reason: 'Generator to Transformer' };
            }

            // Producer -> Consumer: check if consumer accepts electricity
            if (sourceType === 'producer' && targetType === 'consumer') {
                if (targetCarrier === 'electricity' || targetCarrier === 'both') {
                    return { valid: true, carrier: 'electricity', reason: 'Generator to Consumer (electricity)' };
                }
                return { valid: false, carrier: null, reason: 'Consumer does not accept electricity' };
            }

            // Producer -> Storage (electricity): batteries only
            if (sourceType === 'producer' && targetType === 'storage') {
                if (targetCarrier === 'electricity') {
                    return { valid: true, carrier: 'electricity', reason: 'Generator to Battery' };
                }
                return { valid: false, carrier: null, reason: 'H2 Storage does not accept electricity' };
            }

            // Converter -> Consumer: check if consumer accepts hydrogen
            if (sourceType === 'converter' && targetType === 'consumer') {
                if (targetCarrier === 'hydrogen' || targetCarrier === 'both') {
                    return { valid: true, carrier: 'hydrogen', reason: 'Transformer to Consumer (hydrogen)' };
                }
                return { valid: false, carrier: null, reason: 'Consumer does not accept hydrogen' };
            }

            // Converter -> Storage (hydrogen): H2 tanks only
            if (sourceType === 'converter' && targetType === 'storage') {
                if (targetCarrier === 'hydrogen') {
                    return { valid: true, carrier: 'hydrogen', reason: 'Transformer to H2 Storage' };
                }
                return { valid: false, carrier: null, reason: 'Battery does not accept hydrogen' };
            }

            // Storage -> Converter: only batteries can supply electrolyzers
            if (sourceType === 'storage' && targetType === 'converter') {
                if (sourceCarrier === 'electricity') {
                    return { valid: true, carrier: 'electricity', reason: 'Battery to Transformer' };
                }
                return { valid: false, carrier: null, reason: 'H2 Storage cannot supply Transformers' };
            }

            // Storage -> Consumer
            if (sourceType === 'storage' && targetType === 'consumer') {
                if (sourceCarrier === 'electricity' && (targetCarrier === 'electricity' || targetCarrier === 'both')) {
                    return { valid: true, carrier: 'electricity', reason: 'Battery to Consumer' };
                }
                if (sourceCarrier === 'hydrogen' && (targetCarrier === 'hydrogen' || targetCarrier === 'both')) {
                    return { valid: true, carrier: 'hydrogen', reason: 'H2 Storage to Consumer' };
                }
                return { valid: false, carrier: null, reason: 'Carrier mismatch' };
            }

            return { valid: false, carrier: null, reason: 'Invalid connection type' };
        }

        // Get carrier type for a node
        function getNodeCarrier(nodeName) {
            // Check generators (electricity)
            const gen = nodeRegistry.generators.find(g => g.name === nodeName);
            if (gen) return 'electricity';

            // Check transformers (output hydrogen)
            const trans = nodeRegistry.transformers.find(t => t.name === nodeName);
            if (trans) return trans.output_carrier || 'hydrogen';

            // Check consumers
            const cons = nodeRegistry.consumers.find(c => c.name === nodeName);
            if (cons) return cons.carrier;

            // Check batteries (electricity)
            const batt = (nodeRegistry.batteries || []).find(b => b.name === nodeName);
            if (batt) return 'electricity';

            // Check H2 storage (hydrogen)
            const h2s = (nodeRegistry.h2_storage || []).find(h => h.name === nodeName);
            if (h2s) return 'hydrogen';

            return 'unknown';
        }

        function startConnectionDrag(e) {
            e.preventDefault();
            e.stopPropagation();

            const nodeName = e.target.dataset.name;
            const nodeData = nodes[nodeName];

            connectionDrag.active = true;
            connectionDrag.sourceNode = nodeData;
            connectionDrag.sourceName = nodeName;

            // Create temporary line
            const svg = document.getElementById('pipes-svg');
            const canvas = document.getElementById('network-canvas');
            const rect = canvas.getBoundingClientRect();

            // Convert source node position to screen coordinates
            const startX = ((nodeData.x - 0.5 - panX) * currentZoom + 0.5) * rect.width;
            const startY = ((nodeData.y - 0.5 - panY) * currentZoom + 0.5) * rect.height;

            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('id', 'temp-connection-line');
            line.setAttribute('x1', startX);
            line.setAttribute('y1', startY);
            line.setAttribute('x2', startX);
            line.setAttribute('y2', startY);
            line.setAttribute('stroke', '#4ecca3');
            line.setAttribute('stroke-width', '3');
            line.setAttribute('stroke-dasharray', '8 4');
            line.setAttribute('opacity', '0.8');
            line.style.pointerEvents = 'none';
            svg.appendChild(line);
            connectionDrag.tempLine = line;

            // Highlight valid targets
            highlightValidTargets(nodeName, nodeData.type);

            document.addEventListener('mousemove', doConnectionDrag);
            document.addEventListener('mouseup', stopConnectionDrag);
        }

        function doConnectionDrag(e) {
            if (!connectionDrag.active || !connectionDrag.tempLine) return;

            const canvas = document.getElementById('network-canvas');
            const rect = canvas.getBoundingClientRect();

            // Use screen coordinates directly (SVG is in screen space)
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            connectionDrag.tempLine.setAttribute('x2', mouseX);
            connectionDrag.tempLine.setAttribute('y2', mouseY);

            // Check if hovering over a valid target (uses screen coordinates)
            const targetNode = getNodeAtPosition(mouseX, mouseY, rect);
            if (targetNode && targetNode !== connectionDrag.sourceName) {
                const sourceCarrier = getNodeCarrier(connectionDrag.sourceName);
                const targetCarrier = getNodeCarrier(targetNode);
                const validity = getConnectionValidity(
                    connectionDrag.sourceNode.type,
                    nodes[targetNode].type,
                    sourceCarrier,
                    targetCarrier
                );

                if (validity.valid) {
                    connectionDrag.tempLine.setAttribute('stroke', validity.carrier === 'electricity' ? '#f0c040' : '#3498db');
                    connectionDrag.tempLine.setAttribute('stroke-width', '5');
                } else {
                    connectionDrag.tempLine.setAttribute('stroke', '#e74c3c');
                    connectionDrag.tempLine.setAttribute('stroke-width', '3');
                }
            } else {
                connectionDrag.tempLine.setAttribute('stroke', '#4ecca3');
                connectionDrag.tempLine.setAttribute('stroke-width', '3');
            }
        }

        function stopConnectionDrag(e) {
            if (!connectionDrag.active) return;

            const canvas = document.getElementById('network-canvas');
            const rect = canvas.getBoundingClientRect();
            // Use screen coordinates (SVG is in screen space)
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            // Remove temp line
            if (connectionDrag.tempLine) {
                connectionDrag.tempLine.remove();
            }

            // Remove highlights
            removeTargetHighlights();

            // Check if dropped on a valid target (uses screen coordinates)
            const targetName = getNodeAtPosition(mouseX, mouseY, rect);
            if (targetName && targetName !== connectionDrag.sourceName) {
                const sourceCarrier = getNodeCarrier(connectionDrag.sourceName);
                const targetCarrier = getNodeCarrier(targetName);
                const validity = getConnectionValidity(
                    connectionDrag.sourceNode.type,
                    nodes[targetName].type,
                    sourceCarrier,
                    targetCarrier
                );

                if (validity.valid) {
                    createConnection(connectionDrag.sourceName, targetName, validity.carrier);
                } else {
                    showNetworkStatus(validity.reason, 'error');
                }
            }

            // Reset state
            connectionDrag.active = false;
            connectionDrag.sourceNode = null;
            connectionDrag.sourceName = null;
            connectionDrag.tempLine = null;

            document.removeEventListener('mousemove', doConnectionDrag);
            document.removeEventListener('mouseup', stopConnectionDrag);
        }

        function getNodeAtPosition(x, y, canvasRect) {
            // Check if x,y (screen coordinates) is within any node's bounds
            // Convert each node's world position to screen coordinates
            for (const [name, node] of Object.entries(nodes)) {
                const nodeX = ((node.x - 0.5 - panX) * currentZoom + 0.5) * canvasRect.width;
                const nodeY = ((node.y - 0.5 - panY) * currentZoom + 0.5) * canvasRect.height;
                const dist = Math.sqrt((x - nodeX) ** 2 + (y - nodeY) ** 2);
                // Scale hit radius with zoom
                const hitRadius = Math.max(20, 30 * currentZoom);
                if (dist < hitRadius) {
                    return name;
                }
            }
            return null;
        }

        function highlightValidTargets(sourceName, sourceType) {
            const sourceCarrier = getNodeCarrier(sourceName);
            const canvas = document.getElementById('network-canvas');

            canvas.querySelectorAll('.node').forEach(nodeEl => {
                const targetName = nodeEl.dataset.name;
                if (targetName === sourceName) return;

                const targetNode = nodes[targetName];
                const targetCarrier = getNodeCarrier(targetName);
                const validity = getConnectionValidity(sourceType, targetNode.type, sourceCarrier, targetCarrier);

                if (validity.valid) {
                    nodeEl.classList.add('valid-target');
                } else {
                    nodeEl.classList.add('invalid-target');
                }
            });
        }

        function removeTargetHighlights() {
            const canvas = document.getElementById('network-canvas');
            canvas.querySelectorAll('.node').forEach(nodeEl => {
                nodeEl.classList.remove('valid-target', 'invalid-target');
            });
        }

        async function createConnection(source, target, carrier) {
            // Check if connection already exists
            const existing = connections.find(c =>
                c.source === source && c.target === target && c.carrier === carrier
            );

            if (existing) {
                // If it exists but is disabled, enable it
                if (!existing.enabled) {
                    await toggleConnection(source, target, carrier);
                    showNetworkStatus(`Connection ${source} â†’ ${target} enabled`, 'success');
                } else {
                    showNetworkStatus(`Connection already exists`, 'info');
                }
                return;
            }

            // Create new connection
            try {
                const res = await fetch(`${API_BASE}/api/connections`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ source, target, carrier })
                });
                const result = await res.json();

                if (result.status === 'ok') {
                    connections.push(result.connection);
                    rebuildNodesAndEdgesWithConnections();
                    showNetworkStatus(`Connected ${source} â†’ ${target} (${carrier})`, 'success');
                } else {
                    showNetworkStatus('Error: ' + result.message, 'error');
                }
            } catch (e) {
                showNetworkStatus('Error: ' + e.message, 'error');
            }
        }

        async function updateNetworkPositions() {
            // Build layout dict for API
            const layout = {};
            Object.entries(nodes).forEach(([name, node]) => {
                layout[name] = [(node.x * 6) - 3, ((1 - node.y) * 6) - 3, 0];
            });

            try {
                // Update both network JSON and node registry positions
                await Promise.all([
                    fetch(`${API_BASE}/api/network`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            nodes: Object.entries(nodes).map(([name, node]) => ({
                                name,
                                node_type: node.type,
                                carrier: node.type === 'producer' ? 'electricity' : node.type === 'converter' ? 'both' : 'hydrogen',
                                position: layout[name]
                            }))
                        })
                    }),
                    fetch(`${API_BASE}/api/layout`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(layout)
                    })
                ]);

                // Also update local nodeRegistry positions
                updateLocalRegistryPositions(layout);
            } catch (e) {
                console.error('Failed to update network:', e);
            }
        }

        // Update local nodeRegistry with new positions
        function updateLocalRegistryPositions(layout) {
            nodeRegistry.generators.forEach(g => {
                if (layout[g.name]) g.position = layout[g.name];
            });
            nodeRegistry.transformers.forEach(t => {
                if (layout[t.name]) t.position = layout[t.name];
            });
            nodeRegistry.consumers.forEach(c => {
                if (layout[c.name]) c.position = layout[c.name];
            });
            (nodeRegistry.batteries || []).forEach(b => {
                if (layout[b.name]) b.position = layout[b.name];
            });
            (nodeRegistry.h2_storage || []).forEach(h => {
                if (layout[h.name]) h.position = layout[h.name];
            });
        }

        // Run simulation
        async function runSimulation() {
            const btn = document.querySelector('[onclick="runSimulation()"]');
            const icon = document.getElementById('sim-icon');
            const status = document.getElementById('sim-status');

            btn.disabled = true;
            icon.innerHTML = '<div class="spinner"></div>';

            // Build config with utility function parameters
            const config = {
                periods: parseInt(document.getElementById('periods').value),
                alpha_capacity: parseFloat(document.getElementById('alpha_capacity').value),
                alpha_cost: parseFloat(document.getElementById('alpha_cost').value),
                bravo_capacity: parseFloat(document.getElementById('bravo_capacity').value),
                bravo_efficiency: parseFloat(document.getElementById('bravo_efficiency').value) / 100,
                bravo_cost: parseFloat(document.getElementById('bravo_cost').value),
                grid_cost: parseFloat(document.getElementById('grid_cost').value),
            };

            // Dynamically collect consumer utility params from forms
            if (nodeRegistry && nodeRegistry.consumers) {
                nodeRegistry.consumers.forEach(c => {
                    const name = c.name.toLowerCase();
                    if (c.consumer_type === 'cobb_douglas') {
                        const getVal = (id, def) => {
                            const el = document.getElementById(id);
                            return el ? parseFloat(el.value) : def;
                        };
                        config[`${name}_A`] = getVal(`${name}_A`, c.cd_A || 15);
                        config[`${name}_alpha`] = getVal(`${name}_alpha`, c.cd_alpha || 0.4);
                        config[`${name}_beta`] = getVal(`${name}_beta`, c.cd_beta || 0.6);
                        config[`${name}_h_per_bundle`] = getVal(`${name}_h_per_bundle`, c.cd_h_per_bundle || 1);
                        config[`${name}_e_per_bundle`] = getVal(`${name}_e_per_bundle`, c.cd_e_per_bundle || 3);
                        config[`${name}_max_bundles`] = getVal(`${name}_max_bundles`, c.cd_max_bundles || 15);
                        // Legacy support for Echo
                        if (name === 'echo') {
                            config.echo_A = config.echo_A;
                            config.echo_alpha = config.echo_alpha;
                            config.echo_beta = config.echo_beta;
                            config.echo_h_per_bundle = config.echo_h_per_bundle;
                            config.echo_e_per_bundle = config.echo_e_per_bundle;
                            config.echo_max_bundles = config.echo_max_bundles;
                            config.include_echo = true;
                        }
                    } else {
                        const getVal = (id, def) => {
                            const el = document.getElementById(id);
                            return el ? parseFloat(el.value) : def;
                        };
                        config[`${name}_scale`] = getVal(`${name}_scale`, c.log_scale || 30);
                        config[`${name}_shape`] = getVal(`${name}_shape`, c.log_shape || 5);
                        config[`${name}_max_quantity`] = getVal(`${name}_max_quantity`, c.log_max_quantity || 25);
                        // Legacy support for Charlie/Delta
                        if (name === 'charlie') {
                            config.charlie_scale = config.charlie_scale;
                            config.charlie_shape = config.charlie_shape;
                            config.charlie_max_quantity = config.charlie_max_quantity;
                        }
                        if (name === 'delta') {
                            config.delta_scale = config.delta_scale;
                            config.delta_shape = config.delta_shape;
                            config.delta_max_quantity = config.delta_max_quantity;
                        }
                    }
                });
            }

            try {
                await fetch(`${API_BASE}/api/config`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(config)
                });

                const res = await fetch(`${API_BASE}/api/simulate`, { method: 'POST' });
                const data = await res.json();

                if (data.status === 'ok') {
                    status.className = 'status success';
                    status.textContent = 'Simulation completed!';
                    updateResults(data);
                } else {
                    throw new Error(data.message);
                }
            } catch (e) {
                status.className = 'status error';
                status.textContent = 'Error: ' + e.message;
            }

            btn.disabled = false;
            icon.textContent = 'â–¶';
        }

        // Detailed simulation log storage
        let detailedLogData = null;

        // Helper to safely format numbers (handles null/undefined from NaN sanitization)
        function safeFixed(val, decimals = 2) {
            if (val === null || val === undefined || isNaN(val)) return '0';
            return Number(val).toFixed(decimals);
        }

        async function runDetailedSimulation() {
            const btn = document.querySelector('[onclick="runDetailedSimulation()"]');
            const icon = document.getElementById('log-icon');

            btn.disabled = true;
            icon.textContent = 'â³';

            try {
                const res = await fetch(`${API_BASE}/api/simulate/detailed`, { method: 'POST' });
                const data = await res.json();

                if (data.status === 'ok') {
                    // Build and download CSV directly
                    const logEntries = data.detailed_log;
                    const firstEntry = logEntries[0];

                    // Build CSV header
                    let headers = ['Hour'];
                    for (const name of Object.keys(firstEntry.generators || {})) {
                        headers.push(`${name}_kW`, `${name}_cost_ct`);
                    }
                    for (const name of Object.keys(firstEntry.transformers || {})) {
                        headers.push(`${name}_input_kW`, `${name}_output_kg`, `${name}_cost_ct`);
                    }
                    for (const name of Object.keys(firstEntry.consumers || {})) {
                        headers.push(`${name}_consumption`, `${name}_utility_ct`);
                    }
                    for (const name of Object.keys(firstEntry.storage || {})) {
                        headers.push(`${name}_level`, `${name}_in`, `${name}_out`);
                    }
                    headers.push('Excess_Elec_kW', 'Excess_H2_kg');

                    let csv = headers.join(',') + '\n';

                    // Build CSV rows
                    for (const entry of logEntries) {
                        let row = [entry.hour];

                        for (const [name, genData] of Object.entries(entry.generators || {})) {
                            const val = genData.production_kW !== undefined ? genData.production_kW : genData.supply_kW;
                            row.push(safeFixed(val, 2), safeFixed(genData.cost_ct, 2));
                        }
                        for (const [name, transData] of Object.entries(entry.transformers || {})) {
                            row.push(safeFixed(transData.input_kW, 2), safeFixed(transData.output_kg, 3), safeFixed(transData.cost_ct, 2));
                        }
                        for (const [name, consData] of Object.entries(entry.consumers || {})) {
                            row.push(safeFixed(consData.total_consumption, 3), safeFixed(consData.total_utility, 2));
                        }
                        for (const [name, storData] of Object.entries(entry.storage || {})) {
                            const lvl = storData.level_kWh !== undefined ? storData.level_kWh : storData.level_kg;
                            const inFlow = storData.charge_kW !== undefined ? storData.charge_kW : storData.injection_kg;
                            const outFlow = storData.discharge_kW !== undefined ? storData.discharge_kW : storData.withdrawal_kg;
                            row.push(safeFixed(lvl, 2), safeFixed(inFlow, 2), safeFixed(outFlow, 2));
                        }
                        row.push(
                            safeFixed(entry.excess?.electricity_kW || 0, 2),
                            safeFixed(entry.excess?.hydrogen_kg || 0, 3)
                        );

                        csv += row.join(',') + '\n';
                    }

                    // Trigger download
                    const blob = new Blob([csv], { type: 'text/csv' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `simulation_log_${new Date().toISOString().slice(0, 10)}.csv`;
                    a.click();
                    URL.revokeObjectURL(url);
                } else {
                    throw new Error(data.message);
                }
            } catch (e) {
                alert('Error running simulation: ' + e.message);
                console.error('Detailed simulation error:', e);
            }

            btn.disabled = false;
            icon.textContent = 'ðŸ“‹';
        }

        function updateLogTimestep(t) {
            t = parseInt(t);
            document.getElementById('log-timestep-value').textContent = `Hour ${t}`;

            if (!detailedLogData || !detailedLogData.detailed_log) return;

            const entry = detailedLogData.detailed_log[t];
            if (!entry) return;

            // Generators
            const genDiv = document.getElementById('log-generators');
            let genHtml = '';
            for (const [name, data] of Object.entries(entry.generators || {})) {
                if (data.production_kW !== undefined) {
                    genHtml += `<div style="margin-bottom: 6px;">
                        <span style="color: #f1c40f;">${name}</span>
                        <span style="float: right;">${data.production_kW.toFixed(1)} kW</span>
                        <br><span style="color: #888; font-size: 0.7rem;">Cost: ${data.cost_ct.toFixed(1)} ct | ${data.profile_type || 'grid'}</span>
                    </div>`;
                } else if (data.supply_kW !== undefined) {
                    genHtml += `<div style="margin-bottom: 6px;">
                        <span style="color: #e74c3c;">${name}</span>
                        <span style="float: right;">${data.supply_kW.toFixed(1)} kW</span>
                        <br><span style="color: #888; font-size: 0.7rem;">Cost: ${data.cost_ct.toFixed(1)} ct</span>
                    </div>`;
                }
            }
            genDiv.innerHTML = genHtml || '<span style="color: #666;">No generators</span>';

            // Transformers
            const transDiv = document.getElementById('log-transformers');
            let transHtml = '';
            for (const [name, data] of Object.entries(entry.transformers || {})) {
                transHtml += `<div style="margin-bottom: 6px;">
                    <span style="color: #9b59b6;">${name}</span>
                    <br><span style="color: #888; font-size: 0.7rem;">In: ${data.input_kW.toFixed(1)} kW â†’ Out: ${data.output_kg.toFixed(2)} kg</span>
                    <br><span style="color: #888; font-size: 0.7rem;">Eff: ${(data.efficiency * 100).toFixed(0)}% | Cost: ${data.cost_ct.toFixed(1)} ct</span>
                </div>`;
            }
            transDiv.innerHTML = transHtml || '<span style="color: #666;">No transformers</span>';

            // Consumers
            const consDiv = document.getElementById('log-consumers');
            let consHtml = '';
            for (const [name, data] of Object.entries(entry.consumers || {})) {
                const typeLabel = data.consumer_type.replace('logarithmic_', 'log-').replace('cobb_douglas', 'CD');
                consHtml += `<div style="margin-bottom: 8px; padding-bottom: 6px; border-bottom: 1px solid #333;">
                    <span style="color: #27ae60;">${name}</span>
                    <span style="color: #888; font-size: 0.7rem;"> (${typeLabel})</span>
                    <span style="float: right;">${data.total_consumption.toFixed(2)} ${data.unit}</span>
                    <br><span style="color: #888; font-size: 0.7rem;">Utility: ${data.total_utility.toFixed(1)} ct</span>
                </div>`;

                // Show tranche details if any consumption
                if (data.tranches && data.tranches.length > 0) {
                    consHtml += '<div style="margin-left: 10px; font-size: 0.7rem; color: #666;">';
                    for (const tr of data.tranches) {
                        const pct = tr.max_qty > 0 ? (tr.consumption / tr.max_qty * 100).toFixed(0) : 0;
                        const bar = pct > 0 ? `<span style="color: #4ecca3;">â–“</span>`.repeat(Math.ceil(pct / 20)) : '';
                        consHtml += `T${tr.tranche}: ${tr.consumption.toFixed(2)}/${tr.max_qty.toFixed(1)} @ ${tr.wtp_ct.toFixed(1)}ct ${bar}<br>`;
                    }
                    consHtml += '</div>';
                }
            }
            consDiv.innerHTML = consHtml || '<span style="color: #666;">No consumers</span>';

            // Storage
            const storDiv = document.getElementById('log-storage');
            let storHtml = '';
            for (const [name, data] of Object.entries(entry.storage || {})) {
                if (data.type === 'battery') {
                    storHtml += `<div style="margin-bottom: 6px;">
                        <span style="color: #3498db;">${name}</span>
                        <span style="color: #888;"> (Battery)</span>
                        <br><span style="color: #888; font-size: 0.7rem;">
                            Level: ${data.level_kWh.toFixed(1)}/${data.capacity_kWh} kWh (${data.level_pct}%)
                            <br>Charge: ${data.charge_kW.toFixed(1)} kW | Discharge: ${data.discharge_kW.toFixed(1)} kW
                        </span>
                    </div>`;
                } else if (data.type === 'h2_tank') {
                    storHtml += `<div style="margin-bottom: 6px;">
                        <span style="color: #e67e22;">${name}</span>
                        <span style="color: #888;"> (H2 Tank)</span>
                        <br><span style="color: #888; font-size: 0.7rem;">
                            Level: ${data.level_kg.toFixed(1)}/${data.capacity_kg} kg (${data.level_pct}%)
                            <br>Inject: ${data.injection_kg.toFixed(2)} kg | Withdraw: ${data.withdrawal_kg.toFixed(2)} kg
                        </span>
                    </div>`;
                }
            }

            // Add excess/curtailment
            if (entry.excess) {
                if (entry.excess.electricity_kW > 0.01) {
                    storHtml += `<div style="color: #e74c3c; font-size: 0.75rem;">Curtailed Elec: ${entry.excess.electricity_kW.toFixed(1)} kW</div>`;
                }
                if (entry.excess.hydrogen_kg > 0.01) {
                    storHtml += `<div style="color: #e74c3c; font-size: 0.75rem;">Curtailed H2: ${entry.excess.hydrogen_kg.toFixed(2)} kg</div>`;
                }
            }

            storDiv.innerHTML = storHtml || '<span style="color: #666;">No storage</span>';
        }

        function buildLogTable(logEntries) {
            const thead = document.getElementById('log-table-head');
            const tbody = document.getElementById('log-table-body');

            if (!logEntries || logEntries.length === 0) {
                tbody.innerHTML = '<tr><td>No data</td></tr>';
                return;
            }

            // Build header
            let headers = ['Hour'];
            const firstEntry = logEntries[0];

            // Add generator columns
            for (const name of Object.keys(firstEntry.generators || {})) {
                headers.push(`${name} (kW)`);
            }
            // Add transformer columns
            for (const name of Object.keys(firstEntry.transformers || {})) {
                headers.push(`${name} In`, `${name} Out`);
            }
            // Add consumer columns
            for (const name of Object.keys(firstEntry.consumers || {})) {
                headers.push(`${name}`);
            }
            // Add storage columns
            for (const name of Object.keys(firstEntry.storage || {})) {
                headers.push(`${name} Lvl`);
            }

            thead.innerHTML = '<tr>' + headers.map(h =>
                `<th style="padding: 6px; text-align: left; border-bottom: 1px solid #333; color: #4ecca3;">${h}</th>`
            ).join('') + '</tr>';

            // Build rows
            let rowsHtml = '';
            for (const entry of logEntries) {
                let row = `<td style="padding: 4px; border-bottom: 1px solid #222;">${entry.hour}</td>`;

                for (const [name, data] of Object.entries(entry.generators || {})) {
                    const val = data.production_kW !== undefined ? data.production_kW : data.supply_kW;
                    row += `<td style="padding: 4px; border-bottom: 1px solid #222;">${val.toFixed(1)}</td>`;
                }
                for (const [name, data] of Object.entries(entry.transformers || {})) {
                    row += `<td style="padding: 4px; border-bottom: 1px solid #222;">${data.input_kW.toFixed(1)}</td>`;
                    row += `<td style="padding: 4px; border-bottom: 1px solid #222;">${data.output_kg.toFixed(2)}</td>`;
                }
                for (const [name, data] of Object.entries(entry.consumers || {})) {
                    row += `<td style="padding: 4px; border-bottom: 1px solid #222;">${data.total_consumption.toFixed(2)}</td>`;
                }
                for (const [name, data] of Object.entries(entry.storage || {})) {
                    const lvl = data.level_kWh !== undefined ? data.level_kWh : data.level_kg;
                    row += `<td style="padding: 4px; border-bottom: 1px solid #222;">${lvl.toFixed(1)}</td>`;
                }

                rowsHtml += `<tr>${row}</tr>`;
            }
            tbody.innerHTML = rowsHtml;
        }

        function exportLogCSV() {
            if (!detailedLogData || !detailedLogData.detailed_log) {
                alert('No log data to export. Run detailed simulation first.');
                return;
            }

            const logEntries = detailedLogData.detailed_log;
            const firstEntry = logEntries[0];

            // Build CSV header
            let headers = ['Hour'];
            for (const name of Object.keys(firstEntry.generators || {})) {
                headers.push(`${name}_kW`, `${name}_cost_ct`);
            }
            for (const name of Object.keys(firstEntry.transformers || {})) {
                headers.push(`${name}_input_kW`, `${name}_output_kg`, `${name}_cost_ct`);
            }
            for (const name of Object.keys(firstEntry.consumers || {})) {
                headers.push(`${name}_consumption`, `${name}_utility_ct`);
            }
            for (const name of Object.keys(firstEntry.storage || {})) {
                headers.push(`${name}_level`, `${name}_in`, `${name}_out`);
            }
            headers.push('Excess_Elec_kW', 'Excess_H2_kg');

            let csv = headers.join(',') + '\n';

            // Build CSV rows
            for (const entry of logEntries) {
                let row = [entry.hour];

                for (const [name, data] of Object.entries(entry.generators || {})) {
                    const val = data.production_kW !== undefined ? data.production_kW : data.supply_kW;
                    row.push(val.toFixed(2), data.cost_ct.toFixed(2));
                }
                for (const [name, data] of Object.entries(entry.transformers || {})) {
                    row.push(data.input_kW.toFixed(2), data.output_kg.toFixed(3), data.cost_ct.toFixed(2));
                }
                for (const [name, data] of Object.entries(entry.consumers || {})) {
                    row.push(data.total_consumption.toFixed(3), data.total_utility.toFixed(2));
                }
                for (const [name, data] of Object.entries(entry.storage || {})) {
                    const lvl = data.level_kWh !== undefined ? data.level_kWh : data.level_kg;
                    const inFlow = data.charge_kW !== undefined ? data.charge_kW : data.injection_kg;
                    const outFlow = data.discharge_kW !== undefined ? data.discharge_kW : data.withdrawal_kg;
                    row.push(lvl.toFixed(2), inFlow.toFixed(2), outFlow.toFixed(2));
                }
                row.push(
                    (entry.excess?.electricity_kW || 0).toFixed(2),
                    (entry.excess?.hydrogen_kg || 0).toFixed(3)
                );

                csv += row.join(',') + '\n';
            }

            // Download
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `simulation_log_${new Date().toISOString().slice(0, 10)}.csv`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function updateResults(data) {
            const s = data.summary;
            const includeEcho = data.config && data.config.include_echo !== false;

            // Update time series charts
            if (data.flows) {
                updateCharts(data);
            }

            // Economic results
            document.getElementById('res-costs').textContent = (s.total_costs || 0).toFixed(0) + ' ct';
            document.getElementById('res-utility').textContent = (s.total_utility || 0).toFixed(0) + ' ct';
            document.getElementById('res-welfare').textContent = (s.total_welfare || 0).toFixed(0) + ' ct';
            document.getElementById('res-welfare').className = 'value ' + (s.total_welfare >= 0 ? 'positive' : 'negative');

            // Production
            document.getElementById('res-alpha').textContent = (s.total_alpha_production || 0).toFixed(1) + ' kWh';
            document.getElementById('res-grid').textContent = (s.total_grid_supply || 0).toFixed(1) + ' kWh';

            // Consumption by consumer
            document.getElementById('res-charlie').textContent = (s.charlie_hydrogen_consumed || 0).toFixed(1) + ' kg';
            document.getElementById('res-delta').textContent = (s.delta_electricity_consumed || 0).toFixed(1) + ' kWh';
            document.getElementById('res-echo-bundles').textContent = includeEcho ?
                (s.echo_bundles_consumed || 0).toFixed(1) : 'N/A';

            // Totals and Echo breakdown
            document.getElementById('res-total-h2').textContent = (s.total_hydrogen_consumed || 0).toFixed(1) + ' kg';
            document.getElementById('res-total-elec').textContent = (s.total_electricity_consumed || 0).toFixed(1) + ' kWh';

            // Echo breakdown
            const echoBreakdown = document.getElementById('echo-breakdown');
            if (includeEcho) {
                echoBreakdown.style.display = 'grid';
                document.getElementById('res-echo-h2').textContent = (s.echo_hydrogen_consumed || 0).toFixed(1) + ' kg';
                document.getElementById('res-echo-elec').textContent = (s.echo_electricity_consumed || 0).toFixed(1) + ' kWh';
            } else {
                echoBreakdown.style.display = 'none';
            }

            // H2 marginal cost
            if (data.price_analysis && data.price_analysis.hydrogen) {
                document.getElementById('res-h2-cost').textContent =
                    data.price_analysis.hydrogen.marginal_cost.toFixed(2) + ' ct/kWh';
            }

        }

        // Blender functions
        async function launchBlender() {
            const status = document.getElementById('blender-status');
            try {
                const res = await fetch(`${API_BASE}/api/blender/launch`, { method: 'POST' });
                const data = await res.json();
                status.className = 'status ' + (data.status === 'ok' ? 'success' : 'info');
                status.textContent = data.message;
            } catch (e) {
                status.className = 'status error';
                status.textContent = 'Error: ' + e.message;
            }
        }

        async function exportToBlender() {
            const status = document.getElementById('blender-status');
            try {
                const res = await fetch(`${API_BASE}/api/blender/export`, { method: 'POST' });
                const data = await res.json();
                status.className = 'status ' + (data.status === 'ok' ? 'success' : 'error');
                status.textContent = data.message;
            } catch (e) {
                status.className = 'status error';
                status.textContent = 'Error: ' + e.message;
            }
        }

        async function syncFromBlender() {
            const status = document.getElementById('blender-status');
            try {
                const res = await fetch(`${API_BASE}/api/blender/sync`, { method: 'POST' });
                const data = await res.json();
                if (data.status === 'ok') {
                    status.className = 'status success';
                    status.textContent = 'Synced from Blender!';
                    loadNetwork();
                } else {
                    throw new Error(data.message);
                }
            } catch (e) {
                status.className = 'status error';
                status.textContent = 'Error: ' + e.message;
            }
        }

        window.addEventListener('resize', renderNetwork);

        // =========================================
        // Time Series Charts with Plotly
        // =========================================

        const chartColors = {
            alpha: '#4ecca3',      // Green - Alpha production
            grid: '#e74c3c',       // Red - Grid supply
            bravo: '#f0c040',      // Yellow - Electrolyzer
            delta: '#3498db',      // Blue - Delta consumption
            charlie: '#9b59b6',    // Purple - Charlie consumption
            hydrogen: '#1abc9c',   // Teal - Hydrogen
            echo: '#e67e22',       // Orange - Echo consumption
            battery: '#00bcd4',    // Cyan - Battery storage
            h2storage: '#ff9800'   // Amber - H2 storage
        };

        const chartLayout = {
            paper_bgcolor: 'rgba(0,0,0,0)',
            plot_bgcolor: 'rgba(0,0,0,0.2)',
            font: { color: '#eee', size: 11 },
            margin: { t: 40, r: 20, b: 50, l: 60 },
            legend: { orientation: 'h', y: -0.15 },
            xaxis: {
                title: 'Hour',
                gridcolor: 'rgba(255,255,255,0.1)',
                zerolinecolor: 'rgba(255,255,255,0.2)'
            },
            yaxis: {
                gridcolor: 'rgba(255,255,255,0.1)',
                zerolinecolor: 'rgba(255,255,255,0.2)'
            }
        };

        function initCharts() {
            // Electricity chart placeholder
            Plotly.newPlot('chart-electricity', [], {
                ...chartLayout,
                title: { text: 'Electricity Flows', font: { size: 14, color: '#4ecca3' } },
                yaxis: { ...chartLayout.yaxis, title: 'Power (kW)' }
            }, { responsive: true });

            // Hydrogen chart placeholder
            Plotly.newPlot('chart-hydrogen', [], {
                ...chartLayout,
                title: { text: 'Hydrogen Flows', font: { size: 14, color: '#1abc9c' } },
                yaxis: { ...chartLayout.yaxis, title: 'Flow (kg/h)' }
            }, { responsive: true });

            // Stacked area chart placeholder
            Plotly.newPlot('chart-stacked', [], {
                ...chartLayout,
                title: { text: 'Energy Balance Over Time', font: { size: 14, color: '#4ecca3' } },
                yaxis: { ...chartLayout.yaxis, title: 'Energy (kWh)' }
            }, { responsive: true });

            // Battery storage chart placeholder
            Plotly.newPlot('chart-battery', [], {
                ...chartLayout,
                title: { text: 'Battery Storage', font: { size: 14, color: '#00bcd4' } },
                yaxis: { ...chartLayout.yaxis, title: 'State of Charge (kWh)' }
            }, { responsive: true });

            // H2 storage chart placeholder
            Plotly.newPlot('chart-h2storage', [], {
                ...chartLayout,
                title: { text: 'H2 Storage', font: { size: 14, color: '#ff9800' } },
                yaxis: { ...chartLayout.yaxis, title: 'Stored H2 (kg)' }
            }, { responsive: true });
        }

        function updateCharts(data) {
            const flows = data.flows;
            const periods = data.config.periods;
            const hours = Array.from({ length: periods }, (_, i) => i);

            // Extract flow data (handle various formats and naming conventions)
            const getFlowData = (flowNames) => {
                // Accept array of possible names
                const names = Array.isArray(flowNames) ? flowNames : [flowNames];
                for (const name of names) {
                    // Try exact match first
                    if (flows[name]) {
                        const flow = flows[name];
                        if (flow.length === 0) continue;
                        // If nested array [[val], [val], ...], extract values
                        if (Array.isArray(flow[0])) {
                            return flow.map(v => v[0] || 0);
                        }
                        return flow;
                    }
                    // Try case-insensitive match
                    const key = Object.keys(flows).find(k => k.toLowerCase() === name.toLowerCase());
                    if (key) {
                        const flow = flows[key];
                        if (flow.length === 0) continue;
                        if (Array.isArray(flow[0])) {
                            return flow.map(v => v[0] || 0);
                        }
                        return flow;
                    }
                }
                return new Array(periods).fill(0);
            };

            // Get all flow data (try multiple possible names)
            const alphaProduction = getFlowData(['Alpha_production', 'alpha_production']);
            const gridSupply = getFlowData(['Grid_supply', 'grid_supply']);
            const bravoConversion = getFlowData(['Bravo_conversion', 'bravo_conversion']);
            const deltaConsumption = getFlowData(['Delta_consumption', 'delta_consumption']);
            const charlieConsumption = getFlowData(['Charlie_consumption', 'charlie_consumption']);
            const echoConsumption = getFlowData(['Echo_consumption', 'echo_consumption']);
            const echoHydrogen = getFlowData(['Echo_hydrogen', 'echo_hydrogen']);
            const echoElectricity = getFlowData(['Echo_electricity', 'echo_electricity']);

            // Estimate electrolyzer input/output from conversion data
            const bravoInput = bravoConversion.map(v => v / (data.config.bravo_efficiency || 0.7));
            const bravoOutput = bravoConversion;

            // Include Echo?
            const includeEcho = data.config && data.config.include_echo !== false;

            // Electricity chart - production vs consumption
            const electricityTraces = [
                {
                    x: hours,
                    y: alphaProduction,
                    name: 'Alpha Production',
                    type: 'scatter',
                    mode: 'lines+markers',
                    line: { color: chartColors.alpha, width: 2 },
                    marker: { size: 4 }
                },
                {
                    x: hours,
                    y: gridSupply,
                    name: 'Grid Supply',
                    type: 'scatter',
                    mode: 'lines+markers',
                    line: { color: chartColors.grid, width: 2, dash: 'dash' },
                    marker: { size: 4 }
                },
                {
                    x: hours,
                    y: bravoInput,
                    name: 'To Electrolyzer',
                    type: 'scatter',
                    mode: 'lines+markers',
                    line: { color: chartColors.bravo, width: 2 },
                    marker: { size: 4 }
                },
                {
                    x: hours,
                    y: deltaConsumption,
                    name: 'Delta Consumption',
                    type: 'scatter',
                    mode: 'lines+markers',
                    line: { color: chartColors.delta, width: 2 },
                    marker: { size: 4 }
                }
            ];

            // Add Echo electricity if enabled
            if (includeEcho) {
                electricityTraces.push({
                    x: hours,
                    y: echoElectricity,
                    name: 'Echo (Elec)',
                    type: 'scatter',
                    mode: 'lines+markers',
                    line: { color: chartColors.echo, width: 2, dash: 'dot' },
                    marker: { size: 4 }
                });
            }

            Plotly.react('chart-electricity', electricityTraces, {
                ...chartLayout,
                title: { text: 'Electricity Flows', font: { size: 14, color: '#4ecca3' } },
                yaxis: { ...chartLayout.yaxis, title: 'Power (kW)' }
            });

            // Hydrogen chart
            const hydrogenTraces = [
                {
                    x: hours,
                    y: bravoOutput,
                    name: 'Bravo Production',
                    type: 'scatter',
                    mode: 'lines+markers',
                    fill: 'tozeroy',
                    line: { color: chartColors.hydrogen, width: 2 },
                    fillcolor: 'rgba(26, 188, 156, 0.3)'
                },
                {
                    x: hours,
                    y: charlieConsumption,
                    name: 'Charlie Consumption',
                    type: 'scatter',
                    mode: 'lines+markers',
                    line: { color: chartColors.charlie, width: 2 },
                    marker: { size: 5 }
                }
            ];

            // Add Echo hydrogen if enabled
            if (includeEcho) {
                hydrogenTraces.push({
                    x: hours,
                    y: echoHydrogen,
                    name: 'Echo (H2)',
                    type: 'scatter',
                    mode: 'lines+markers',
                    line: { color: chartColors.echo, width: 2, dash: 'dot' },
                    marker: { size: 5 }
                });
            }

            Plotly.react('chart-hydrogen', hydrogenTraces, {
                ...chartLayout,
                title: { text: 'Hydrogen Flows', font: { size: 14, color: '#1abc9c' } },
                yaxis: { ...chartLayout.yaxis, title: 'Flow (kg/h)' }
            });

            // Stacked area chart - energy balance
            const stackedTraces = [
                {
                    x: hours,
                    y: alphaProduction,
                    name: 'Alpha (Local)',
                    type: 'scatter',
                    mode: 'lines',
                    fill: 'tozeroy',
                    line: { color: chartColors.alpha, width: 0 },
                    fillcolor: 'rgba(78, 204, 163, 0.7)',
                    stackgroup: 'supply'
                },
                {
                    x: hours,
                    y: gridSupply,
                    name: 'Grid Import',
                    type: 'scatter',
                    mode: 'lines',
                    fill: 'tonexty',
                    line: { color: chartColors.grid, width: 0 },
                    fillcolor: 'rgba(231, 76, 60, 0.7)',
                    stackgroup: 'supply'
                },
                {
                    x: hours,
                    y: deltaConsumption.map(v => -v),
                    name: 'Delta (Direct)',
                    type: 'scatter',
                    mode: 'lines',
                    fill: 'tozeroy',
                    line: { color: chartColors.delta, width: 0 },
                    fillcolor: 'rgba(52, 152, 219, 0.7)',
                    stackgroup: 'demand'
                },
                {
                    x: hours,
                    y: bravoInput.map(v => -v),
                    name: 'Electrolyzer',
                    type: 'scatter',
                    mode: 'lines',
                    fill: 'tonexty',
                    line: { color: chartColors.bravo, width: 0 },
                    fillcolor: 'rgba(240, 192, 64, 0.7)',
                    stackgroup: 'demand'
                }
            ];

            // Add Echo electricity demand if enabled
            if (includeEcho) {
                stackedTraces.push({
                    x: hours,
                    y: echoElectricity.map(v => -v),
                    name: 'Echo (Elec)',
                    type: 'scatter',
                    mode: 'lines',
                    fill: 'tonexty',
                    line: { color: chartColors.echo, width: 0 },
                    fillcolor: 'rgba(230, 126, 34, 0.7)',
                    stackgroup: 'demand'
                });
            }

            Plotly.react('chart-stacked', stackedTraces, {
                ...chartLayout,
                title: { text: 'Energy Balance: Supply (+) vs Demand (-)', font: { size: 14, color: '#4ecca3' } },
                yaxis: { ...chartLayout.yaxis, title: 'Power (kW)', zeroline: true, zerolinewidth: 2 },
                barmode: 'relative'
            });

            // Storage charts
            const storageSection = document.getElementById('storage-charts-section');
            const batteryTraces = [];
            const h2StorageTraces = [];
            // Battery colors with fill variants
            const storageColors = [
                { line: '#00bcd4', fill: 'rgba(0, 188, 212, 0.3)' },
                { line: '#26c6da', fill: 'rgba(38, 198, 218, 0.3)' },
                { line: '#4dd0e1', fill: 'rgba(77, 208, 225, 0.3)' },
                { line: '#80deea', fill: 'rgba(128, 222, 234, 0.3)' }
            ];
            // H2 storage colors with fill variants
            const h2Colors = [
                { line: '#ff9800', fill: 'rgba(255, 152, 0, 0.3)' },
                { line: '#ffa726', fill: 'rgba(255, 167, 38, 0.3)' },
                { line: '#ffb74d', fill: 'rgba(255, 183, 77, 0.3)' },
                { line: '#ffcc80', fill: 'rgba(255, 204, 128, 0.3)' }
            ];

            // Find all battery storage flows
            let batteryCount = 0;
            let h2Count = 0;

            Object.keys(flows).forEach(key => {
                if (key.endsWith('_storage')) {
                    const name = key.replace('_storage', '');
                    const flowData = flows[key];

                    // Try to extract storage level data
                    let storageLevel = [];
                    if (flowData && flowData.length > 0) {
                        // Handle DataFrame-like structure or simple array
                        if (typeof flowData[0] === 'object' && !Array.isArray(flowData[0])) {
                            // It's an array of objects, try to find the storage level column
                            storageLevel = flowData.map(row => {
                                // Look for columns containing 'storage_content' or similar
                                for (const col of Object.keys(row)) {
                                    if (col.includes('storage_content') || col.includes('level')) {
                                        return row[col] || 0;
                                    }
                                }
                                // Fall back to first numeric value
                                for (const col of Object.keys(row)) {
                                    if (typeof row[col] === 'number') return row[col];
                                }
                                return 0;
                            });
                        } else if (Array.isArray(flowData[0])) {
                            // Nested array
                            storageLevel = flowData.map(v => v[0] || 0);
                        } else {
                            // Simple array
                            storageLevel = flowData;
                        }
                    }

                    if (storageLevel.length === 0) {
                        storageLevel = new Array(periods).fill(0);
                    }

                    // Determine if it's battery or H2 storage based on node registry
                    const isBattery = nodeRegistry.batteries.some(b => b.name === name);
                    const isH2 = nodeRegistry.h2_storage.some(h => h.name === name);

                    if (isBattery) {
                        const colorSet = storageColors[batteryCount % storageColors.length];
                        batteryTraces.push({
                            x: hours,
                            y: storageLevel,
                            name: name,
                            type: 'scatter',
                            mode: 'lines+markers',
                            fill: 'tozeroy',
                            line: { color: colorSet.line, width: 2 },
                            fillcolor: colorSet.fill,
                            marker: { size: 4 }
                        });
                        batteryCount++;
                    } else if (isH2) {
                        const colorSet = h2Colors[h2Count % h2Colors.length];
                        h2StorageTraces.push({
                            x: hours,
                            y: storageLevel,
                            name: name,
                            type: 'scatter',
                            mode: 'lines+markers',
                            fill: 'tozeroy',
                            line: { color: colorSet.line, width: 2 },
                            fillcolor: colorSet.fill,
                            marker: { size: 4 }
                        });
                        h2Count++;
                    }
                }
            });

            // Show/hide storage section based on whether we have storage data
            if (batteryTraces.length > 0 || h2StorageTraces.length > 0) {
                storageSection.style.display = 'block';

                if (batteryTraces.length > 0) {
                    Plotly.react('chart-battery', batteryTraces, {
                        ...chartLayout,
                        title: { text: 'Battery Storage State', font: { size: 14, color: '#00bcd4' } },
                        yaxis: { ...chartLayout.yaxis, title: 'State of Charge (kWh)' }
                    });
                } else {
                    Plotly.react('chart-battery', [{
                        x: hours,
                        y: new Array(periods).fill(0),
                        name: 'No batteries',
                        type: 'scatter',
                        mode: 'lines',
                        line: { color: '#666', width: 1, dash: 'dot' }
                    }], {
                        ...chartLayout,
                        title: { text: 'Battery Storage (None configured)', font: { size: 14, color: '#666' } },
                        yaxis: { ...chartLayout.yaxis, title: 'State of Charge (kWh)' }
                    });
                }

                if (h2StorageTraces.length > 0) {
                    Plotly.react('chart-h2storage', h2StorageTraces, {
                        ...chartLayout,
                        title: { text: 'H2 Storage State', font: { size: 14, color: '#ff9800' } },
                        yaxis: { ...chartLayout.yaxis, title: 'Stored H2 (kg)' }
                    });
                } else {
                    Plotly.react('chart-h2storage', [{
                        x: hours,
                        y: new Array(periods).fill(0),
                        name: 'No H2 storage',
                        type: 'scatter',
                        mode: 'lines',
                        line: { color: '#666', width: 1, dash: 'dot' }
                    }], {
                        ...chartLayout,
                        title: { text: 'H2 Storage (None configured)', font: { size: 14, color: '#666' } },
                        yaxis: { ...chartLayout.yaxis, title: 'Stored H2 (kg)' }
                    });
                }
            } else {
                storageSection.style.display = 'none';
            }
        }

        // Initialize charts on page load
        document.addEventListener('DOMContentLoaded', initCharts);

        // =========================================
        // Node Management Functions
        // =========================================

        let nodeRegistry = {
            generators: [],
            transformers: [],
            consumers: [],
            batteries: [],
            h2_storage: []
        };

        let currentNodeType = null;
        let editingNodeName = null;

        // NATO phonetic alphabet for auto-naming nodes
        const NATO_ALPHABET = [
            'Alpha', 'Bravo', 'Charlie', 'Delta', 'Echo', 'Foxtrot', 'Golf', 'Hotel',
            'India', 'Juliet', 'Kilo', 'Lima', 'Mike', 'November', 'Oscar', 'Papa',
            'Quebec', 'Romeo', 'Sierra', 'Tango', 'Uniform', 'Victor', 'Whiskey',
            'Xray', 'Yankee', 'Zulu'
        ];

        // Get all used node names across all categories
        function getAllUsedNames() {
            const names = new Set();
            for (const cat of ['generators', 'transformers', 'consumers', 'batteries', 'h2_storage']) {
                for (const node of (nodeRegistry[cat] || [])) {
                    names.add(node.name);
                }
            }
            return names;
        }

        // Get first unused NATO alphabet name
        function getNextNatoName() {
            const usedNames = getAllUsedNames();
            for (const name of NATO_ALPHABET) {
                if (!usedNames.has(name)) {
                    return name;
                }
            }
            // Fallback if all NATO names are used
            return `Node${usedNames.size + 1}`;
        }

        // Preset Management Functions
        async function loadPresetList() {
            try {
                const res = await fetch(`${API_BASE}/api/presets`);
                const presets = await res.json();
                const select = document.getElementById('preset-select');
                select.innerHTML = '<option value="">-- Select Preset --</option>' +
                    presets.map(p => `<option value="${p.name}">${p.name} (${p.generators}G/${p.transformers}T/${p.consumers}C${p.batteries ? '/' + p.batteries + 'B' : ''}${p.h2_storage ? '/' + p.h2_storage + 'H' : ''})</option>`).join('');
            } catch (e) {
                console.error('Failed to load presets:', e);
            }
        }

        async function loadSelectedPreset() {
            const select = document.getElementById('preset-select');
            const presetName = select.value;
            if (!presetName) {
                alert('Please select a preset first');
                return;
            }

            if (!confirm(`Load preset "${presetName}"? This will replace all current nodes and connections.`)) {
                return;
            }

            try {
                const res = await fetch(`${API_BASE}/api/presets/${presetName}/load`, {
                    method: 'POST'
                });
                const result = await res.json();
                if (result.status === 'ok') {
                    // Reload everything
                    await loadConnections();
                    await loadNodes();
                    showStatus('node-status', `Loaded preset: ${presetName}`, 'success');
                } else {
                    showStatus('node-status', result.message || 'Failed to load preset', 'error');
                }
            } catch (e) {
                console.error('Failed to load preset:', e);
                showStatus('node-status', 'Failed to load preset', 'error');
            }
        }

        // Load nodes from backend
        async function loadNodes() {
            try {
                const res = await fetch(`${API_BASE}/api/nodes`);
                nodeRegistry = await res.json();
                renderNodeLists();
                renderConsumerUtilityForms();
                // Always fetch fresh connections from backend (they may have changed when nodes were added/removed)
                const connRes = await fetch(`${API_BASE}/api/connections`);
                connections = await connRes.json();
                rebuildNodesAndEdgesWithConnections();
            } catch (e) {
                console.error('Failed to load nodes:', e);
            }
        }

        // Render node lists in the UI
        function renderNodeLists() {
            // Generators
            const genList = document.getElementById('generators-list');
            genList.innerHTML = nodeRegistry.generators.map(g => `
                <div class="node-item">
                    <span class="node-name">${g.name}</span>
                    <span class="node-type">${g.profile_type || 'solar'}</span>
                    <button class="btn-small btn-edit" onclick="editNode('generator', '${g.name}')">Edit</button>
                    <button class="btn-small btn-delete" onclick="deleteNode('generator', '${g.name}')">X</button>
                </div>
            `).join('');
            document.getElementById('gen-count').textContent = nodeRegistry.generators.length;

            // Transformers
            const transList = document.getElementById('transformers-list');
            transList.innerHTML = nodeRegistry.transformers.map(t => `
                <div class="node-item">
                    <span class="node-name">${t.name}</span>
                    <span class="node-type">${(t.efficiency * 100).toFixed(0)}%</span>
                    <button class="btn-small btn-edit" onclick="editNode('transformer', '${t.name}')">Edit</button>
                    <button class="btn-small btn-delete" onclick="deleteNode('transformer', '${t.name}')">X</button>
                </div>
            `).join('');
            document.getElementById('trans-count').textContent = nodeRegistry.transformers.length;

            // Consumers
            const consList = document.getElementById('consumers-list');
            consList.innerHTML = nodeRegistry.consumers.map(c => {
                const typeShort = c.consumer_type === 'cobb_douglas' ? 'C-D' :
                                  c.consumer_type.includes('elec') ? 'E' : 'H2';
                return `
                <div class="node-item">
                    <span class="node-name">${c.name}</span>
                    <span class="node-type">${typeShort}</span>
                    <button class="btn-small btn-edit" onclick="editNode('consumer', '${c.name}')">Edit</button>
                    <button class="btn-small btn-delete" onclick="deleteNode('consumer', '${c.name}')">X</button>
                </div>
            `}).join('');
            document.getElementById('cons-count').textContent = nodeRegistry.consumers.length;

            // Batteries
            const battList = document.getElementById('batteries-list');
            battList.innerHTML = (nodeRegistry.batteries || []).map(b => `
                <div class="node-item">
                    <span class="node-name">${b.name}</span>
                    <span class="node-type">${b.capacity}kWh</span>
                    <button class="btn-small btn-edit" onclick="editNode('battery', '${b.name}')">Edit</button>
                    <button class="btn-small btn-delete" onclick="deleteNode('battery', '${b.name}')">X</button>
                </div>
            `).join('');
            document.getElementById('batt-count').textContent = (nodeRegistry.batteries || []).length;

            // H2 Storage
            const h2sList = document.getElementById('h2storage-list');
            h2sList.innerHTML = (nodeRegistry.h2_storage || []).map(h => `
                <div class="node-item">
                    <span class="node-name">${h.name}</span>
                    <span class="node-type">${h.capacity}kg</span>
                    <button class="btn-small btn-edit" onclick="editNode('h2_storage', '${h.name}')">Edit</button>
                    <button class="btn-small btn-delete" onclick="deleteNode('h2_storage', '${h.name}')">X</button>
                </div>
            `).join('');
            document.getElementById('h2s-count').textContent = (nodeRegistry.h2_storage || []).length;
        }

        // Render consumer utility parameter forms dynamically
        function renderConsumerUtilityForms() {
            const container = document.getElementById('consumer-utility-container');
            if (!nodeRegistry || !nodeRegistry.consumers || nodeRegistry.consumers.length === 0) {
                container.innerHTML = '<p style="color:#666">No consumers defined</p>';
                return;
            }

            let html = '';
            nodeRegistry.consumers.forEach(c => {
                const name = c.name.toLowerCase();
                const carrierLabel = c.carrier === 'hydrogen' ? 'H2' :
                                    c.carrier === 'electricity' ? 'Elec' : 'Both';

                if (c.consumer_type === 'cobb_douglas') {
                    html += `
                        <h3 style="display:flex;align-items:center;gap:10px;">
                            ${c.name} - ${carrierLabel} (Cobb-Douglas)
                        </h3>
                        <p style="color:#666;font-size:0.75rem;margin-bottom:8px;">U(h,e) = A Ã— h<sup>Î±</sup> Ã— e<sup>Î²</sup></p>
                        <div class="param-row-3">
                            <div class="param-group">
                                <label>Scale (A)</label>
                                <input type="number" id="${name}_A" value="${c.cd_A || 15}" min="0.1" step="1">
                            </div>
                            <div class="param-group">
                                <label>H2 exp (Î±)</label>
                                <input type="number" id="${name}_alpha" value="${c.cd_alpha || 0.4}" min="0.01" max="1" step="0.05">
                            </div>
                            <div class="param-group">
                                <label>Elec exp (Î²)</label>
                                <input type="number" id="${name}_beta" value="${c.cd_beta || 0.6}" min="0.01" max="1" step="0.05">
                            </div>
                        </div>
                        <div class="param-row-3">
                            <div class="param-group">
                                <label>H2/bundle (kg)</label>
                                <input type="number" id="${name}_h_per_bundle" value="${c.cd_h_per_bundle || 1}" min="0.1" step="0.5">
                            </div>
                            <div class="param-group">
                                <label>Elec/bundle (kWh)</label>
                                <input type="number" id="${name}_e_per_bundle" value="${c.cd_e_per_bundle || 3}" min="0.1" step="0.5">
                            </div>
                            <div class="param-group">
                                <label>Max bundles/h</label>
                                <input type="number" id="${name}_max_bundles" value="${c.cd_max_bundles || 15}" min="1" step="1">
                            </div>
                        </div>
                    `;
                } else {
                    // Logarithmic utility
                    const unit = c.carrier === 'hydrogen' ? 'kg/h' : 'kWh/h';
                    html += `
                        <h3>${c.name} - ${carrierLabel} (Logarithmic)</h3>
                        <p style="color:#666;font-size:0.75rem;margin-bottom:8px;">U(x) = scale Ã— ln(1 + x/shape)</p>
                        <div class="param-row-3">
                            <div class="param-group">
                                <label>Scale (a)</label>
                                <input type="number" id="${name}_scale" value="${c.log_scale || 30}" min="1" step="1">
                            </div>
                            <div class="param-group">
                                <label>Shape (b)</label>
                                <input type="number" id="${name}_shape" value="${c.log_shape || 5}" min="0.1" step="0.5">
                            </div>
                            <div class="param-group">
                                <label>Max Qty (${unit})</label>
                                <input type="number" id="${name}_max_quantity" value="${c.log_max_quantity || 25}" min="1" step="5">
                            </div>
                        </div>
                    `;
                }
            });

            container.innerHTML = html;
        }

        // Rebuild nodes and edges objects from registry
        function rebuildNodesAndEdges() {
            // Clear existing nodes (keep only from registry)
            nodes = {};
            edges.length = 0;

            // Add generators
            nodeRegistry.generators.forEach((g, i) => {
                const pos = g.position || [0, 2, 0];
                nodes[g.name] = {
                    x: (pos[0] + 3) / 6,
                    y: 1 - (pos[1] + 3) / 6,
                    type: 'producer'
                };
            });

            // Add transformers
            nodeRegistry.transformers.forEach((t, i) => {
                const pos = t.position || [-2, 0, 0];
                nodes[t.name] = {
                    x: (pos[0] + 3) / 6,
                    y: 1 - (pos[1] + 3) / 6,
                    type: 'converter'
                };
                // Create edges from all generators to this transformer
                nodeRegistry.generators.forEach(g => {
                    edges.push({ source: g.name, target: t.name, carrier: 'electricity' });
                });
            });

            // Add consumers
            nodeRegistry.consumers.forEach((c, i) => {
                const pos = c.position || [0, -2, 0];
                nodes[c.name] = {
                    x: (pos[0] + 3) / 6,
                    y: 1 - (pos[1] + 3) / 6,
                    type: 'consumer'
                };
                // Create edges based on carrier type
                if (c.carrier === 'electricity' || c.carrier === 'both') {
                    nodeRegistry.generators.forEach(g => {
                        edges.push({ source: g.name, target: c.name, carrier: 'electricity' });
                    });
                }
                if (c.carrier === 'hydrogen' || c.carrier === 'both') {
                    nodeRegistry.transformers.forEach(t => {
                        edges.push({ source: t.name, target: c.name, carrier: 'hydrogen' });
                    });
                }
            });

            // Add batteries
            (nodeRegistry.batteries || []).forEach((b, i) => {
                const pos = b.position || [3, 0, 0];
                nodes[b.name] = {
                    x: (pos[0] + 3) / 6,
                    y: 1 - (pos[1] + 3) / 6,
                    type: 'storage'
                };
                // Connect to generators (electricity bus)
                nodeRegistry.generators.forEach(g => {
                    edges.push({ source: g.name, target: b.name, carrier: 'electricity' });
                });
            });

            // Add H2 storage
            (nodeRegistry.h2_storage || []).forEach((h, i) => {
                const pos = h.position || [-3, -1, 0];
                nodes[h.name] = {
                    x: (pos[0] + 3) / 6,
                    y: 1 - (pos[1] + 3) / 6,
                    type: 'storage'
                };
                // Connect to transformers (hydrogen bus)
                nodeRegistry.transformers.forEach(t => {
                    edges.push({ source: t.name, target: h.name, carrier: 'hydrogen' });
                });
            });

            renderNetwork();
        }

        // Open modal for adding a node
        function openAddNodeModal(nodeType) {
            currentNodeType = nodeType;
            editingNodeName = null;

            // Set modal title
            const titles = {
                generator: 'Add Generator',
                transformer: 'Add Transformer',
                consumer: 'Add Consumer',
                battery: 'Add Battery',
                h2_storage: 'Add H2 Storage'
            };
            document.getElementById('modal-title').textContent = titles[nodeType];

            // Reset form with auto-generated NATO name
            document.getElementById('node-name').value = getNextNatoName();
            document.getElementById('node-name').disabled = false;

            // Show/hide type-specific fields
            document.getElementById('generator-fields').style.display = nodeType === 'generator' ? 'block' : 'none';
            document.getElementById('transformer-fields').style.display = nodeType === 'transformer' ? 'block' : 'none';
            document.getElementById('consumer-fields').style.display = nodeType === 'consumer' ? 'block' : 'none';
            document.getElementById('battery-fields').style.display = nodeType === 'battery' ? 'block' : 'none';
            document.getElementById('h2storage-fields').style.display = nodeType === 'h2_storage' ? 'block' : 'none';

            // Reset default values
            if (nodeType === 'generator') {
                document.getElementById('gen-capacity').value = 100;
                document.getElementById('gen-cost').value = 8;
                document.getElementById('gen-profile').value = 'solar';
            } else if (nodeType === 'transformer') {
                document.getElementById('trans-capacity').value = 50;
                document.getElementById('trans-efficiency').value = 70;
                document.getElementById('trans-cost').value = 1.5;
            } else if (nodeType === 'consumer') {
                document.getElementById('cons-type').value = 'logarithmic_electricity';
                toggleConsumerParams();
            } else if (nodeType === 'battery') {
                document.getElementById('batt-capacity').value = 100;
                document.getElementById('batt-cost').value = 1;
                document.getElementById('batt-charge-rate').value = 50;
                document.getElementById('batt-discharge-rate').value = 50;
                document.getElementById('batt-eff-in').value = 95;
                document.getElementById('batt-eff-out').value = 95;
                document.getElementById('batt-loss').value = 0.02;
                document.getElementById('batt-initial').value = 50;
                document.getElementById('batt-min').value = 10;
            } else if (nodeType === 'h2_storage') {
                document.getElementById('h2s-capacity').value = 50;
                document.getElementById('h2s-cost').value = 0.5;
                document.getElementById('h2s-injection-rate').value = 10;
                document.getElementById('h2s-withdrawal-rate').value = 10;
                document.getElementById('h2s-eff-in').value = 95;
                document.getElementById('h2s-eff-out').value = 99;
                document.getElementById('h2s-loss').value = 0.01;
                document.getElementById('h2s-initial').value = 50;
            }

            document.getElementById('node-modal').classList.add('active');
        }

        // Close modal
        function closeNodeModal() {
            document.getElementById('node-modal').classList.remove('active');
            currentNodeType = null;
            editingNodeName = null;
        }

        // Toggle consumer params based on type selection
        function toggleConsumerParams() {
            const consType = document.getElementById('cons-type').value;
            document.getElementById('log-params').style.display = consType.startsWith('logarithmic') ? 'block' : 'none';
            document.getElementById('cd-params').style.display = consType === 'cobb_douglas' ? 'block' : 'none';
        }

        // Save node (add or update)
        async function saveNode() {
            const name = document.getElementById('node-name').value.trim();
            if (!name) {
                showNodeStatus('Please enter a node name', 'error');
                return;
            }

            let endpoint, data, method;

            if (currentNodeType === 'generator') {
                endpoint = editingNodeName ? `/api/nodes/generators/${editingNodeName}` : '/api/nodes/generators';
                method = editingNodeName ? 'PUT' : 'POST';
                data = {
                    name: name,
                    capacity: parseFloat(document.getElementById('gen-capacity').value),
                    cost: parseFloat(document.getElementById('gen-cost').value),
                    profile_type: document.getElementById('gen-profile').value
                };
            } else if (currentNodeType === 'transformer') {
                endpoint = editingNodeName ? `/api/nodes/transformers/${editingNodeName}` : '/api/nodes/transformers';
                method = editingNodeName ? 'PUT' : 'POST';
                data = {
                    name: name,
                    capacity: parseFloat(document.getElementById('trans-capacity').value),
                    efficiency: parseFloat(document.getElementById('trans-efficiency').value) / 100,
                    cost: parseFloat(document.getElementById('trans-cost').value)
                };
            } else if (currentNodeType === 'consumer') {
                const consType = document.getElementById('cons-type').value;
                endpoint = editingNodeName ? `/api/nodes/consumers/${editingNodeName}` : '/api/nodes/consumers';
                method = editingNodeName ? 'PUT' : 'POST';
                data = {
                    name: name,
                    consumer_type: consType,
                    carrier: consType === 'logarithmic_electricity' ? 'electricity' :
                             consType === 'logarithmic_hydrogen' ? 'hydrogen' : 'both'
                };

                if (consType.startsWith('logarithmic')) {
                    data.log_scale = parseFloat(document.getElementById('cons-log-scale').value);
                    data.log_shape = parseFloat(document.getElementById('cons-log-shape').value);
                    data.log_max_quantity = parseFloat(document.getElementById('cons-log-max').value);
                } else if (consType === 'cobb_douglas') {
                    data.cd_A = parseFloat(document.getElementById('cons-cd-A').value);
                    data.cd_alpha = parseFloat(document.getElementById('cons-cd-alpha').value);
                    data.cd_beta = parseFloat(document.getElementById('cons-cd-beta').value);
                    data.cd_h_per_bundle = parseFloat(document.getElementById('cons-cd-h').value);
                    data.cd_e_per_bundle = parseFloat(document.getElementById('cons-cd-e').value);
                    data.cd_max_bundles = parseFloat(document.getElementById('cons-cd-max').value);
                }
            } else if (currentNodeType === 'battery') {
                endpoint = editingNodeName ? `/api/nodes/batteries/${editingNodeName}` : '/api/nodes/batteries';
                method = editingNodeName ? 'PUT' : 'POST';
                data = {
                    name: name,
                    capacity: parseFloat(document.getElementById('batt-capacity').value),
                    cost: parseFloat(document.getElementById('batt-cost').value),
                    charge_rate: parseFloat(document.getElementById('batt-charge-rate').value),
                    discharge_rate: parseFloat(document.getElementById('batt-discharge-rate').value),
                    efficiency_in: parseFloat(document.getElementById('batt-eff-in').value) / 100,
                    efficiency_out: parseFloat(document.getElementById('batt-eff-out').value) / 100,
                    loss_rate: parseFloat(document.getElementById('batt-loss').value) / 100,
                    initial_level: parseFloat(document.getElementById('batt-initial').value) / 100,
                    min_level: parseFloat(document.getElementById('batt-min').value) / 100
                };
            } else if (currentNodeType === 'h2_storage') {
                endpoint = editingNodeName ? `/api/nodes/h2_storage/${editingNodeName}` : '/api/nodes/h2_storage';
                method = editingNodeName ? 'PUT' : 'POST';
                data = {
                    name: name,
                    capacity: parseFloat(document.getElementById('h2s-capacity').value),
                    cost: parseFloat(document.getElementById('h2s-cost').value),
                    injection_rate: parseFloat(document.getElementById('h2s-injection-rate').value),
                    withdrawal_rate: parseFloat(document.getElementById('h2s-withdrawal-rate').value),
                    efficiency_in: parseFloat(document.getElementById('h2s-eff-in').value) / 100,
                    efficiency_out: parseFloat(document.getElementById('h2s-eff-out').value) / 100,
                    loss_rate: parseFloat(document.getElementById('h2s-loss').value) / 100,
                    initial_level: parseFloat(document.getElementById('h2s-initial').value) / 100
                };
            }

            // Save these before closeNodeModal() clears them
            const savedNodeType = currentNodeType;
            const isEditing = editingNodeName !== null;

            try {
                const res = await fetch(`${API_BASE}${endpoint}`, {
                    method: method,
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data)
                });
                const result = await res.json();

                if (result.status === 'ok') {
                    closeNodeModal();
                    loadNodes();
                    showNodeStatus(`${savedNodeType} "${name}" ${isEditing ? 'updated' : 'added'} successfully!`, 'success');
                } else {
                    showNodeStatus('Error: ' + result.message, 'error');
                }
            } catch (e) {
                showNodeStatus('Error: ' + e.message, 'error');
            }
        }

        // Edit existing node
        function editNode(nodeType, name) {
            const collections = {
                generator: 'generators',
                transformer: 'transformers',
                consumer: 'consumers',
                battery: 'batteries',
                h2_storage: 'h2_storage'
            };
            const collection = nodeRegistry[collections[nodeType]] || [];
            const node = collection.find(n => n.name === name);
            if (!node) return;

            openAddNodeModal(nodeType);
            editingNodeName = name;

            // Update modal title
            const titles = {
                generator: 'Edit Generator',
                transformer: 'Edit Transformer',
                consumer: 'Edit Consumer',
                battery: 'Edit Battery',
                h2_storage: 'Edit H2 Storage'
            };
            document.getElementById('modal-title').textContent = titles[nodeType];

            // Populate form
            document.getElementById('node-name').value = name;
            document.getElementById('node-name').disabled = true;  // Can't rename

            if (nodeType === 'generator') {
                document.getElementById('gen-capacity').value = node.capacity;
                document.getElementById('gen-cost').value = node.cost;
                document.getElementById('gen-profile').value = node.profile_type || 'solar';
            } else if (nodeType === 'transformer') {
                document.getElementById('trans-capacity').value = node.capacity;
                document.getElementById('trans-efficiency').value = (node.efficiency || 0.7) * 100;
                document.getElementById('trans-cost').value = node.cost;
            } else if (nodeType === 'consumer') {
                document.getElementById('cons-type').value = node.consumer_type;
                toggleConsumerParams();
                if (node.consumer_type.startsWith('logarithmic')) {
                    document.getElementById('cons-log-scale').value = node.log_scale || 30;
                    document.getElementById('cons-log-shape').value = node.log_shape || 5;
                    document.getElementById('cons-log-max').value = node.log_max_quantity || 25;
                } else if (node.consumer_type === 'cobb_douglas') {
                    document.getElementById('cons-cd-A').value = node.cd_A || 15;
                    document.getElementById('cons-cd-alpha').value = node.cd_alpha || 0.4;
                    document.getElementById('cons-cd-beta').value = node.cd_beta || 0.6;
                    document.getElementById('cons-cd-h').value = node.cd_h_per_bundle || 1;
                    document.getElementById('cons-cd-e').value = node.cd_e_per_bundle || 3;
                    document.getElementById('cons-cd-max').value = node.cd_max_bundles || 15;
                }
            } else if (nodeType === 'battery') {
                document.getElementById('batt-capacity').value = node.capacity;
                document.getElementById('batt-cost').value = node.cost;
                document.getElementById('batt-charge-rate').value = node.charge_rate || 50;
                document.getElementById('batt-discharge-rate').value = node.discharge_rate || 50;
                document.getElementById('batt-eff-in').value = (node.efficiency_in || 0.95) * 100;
                document.getElementById('batt-eff-out').value = (node.efficiency_out || 0.95) * 100;
                document.getElementById('batt-loss').value = (node.loss_rate || 0.0002) * 100;
                document.getElementById('batt-initial').value = (node.initial_level || 0.5) * 100;
                document.getElementById('batt-min').value = (node.min_level || 0.1) * 100;
            } else if (nodeType === 'h2_storage') {
                document.getElementById('h2s-capacity').value = node.capacity;
                document.getElementById('h2s-cost').value = node.cost;
                document.getElementById('h2s-injection-rate').value = node.injection_rate || 10;
                document.getElementById('h2s-withdrawal-rate').value = node.withdrawal_rate || 10;
                document.getElementById('h2s-eff-in').value = (node.efficiency_in || 0.95) * 100;
                document.getElementById('h2s-eff-out').value = (node.efficiency_out || 0.99) * 100;
                document.getElementById('h2s-loss').value = (node.loss_rate || 0.0001) * 100;
                document.getElementById('h2s-initial').value = (node.initial_level || 0.5) * 100;
            }
        }

        // Delete node
        async function deleteNode(nodeType, name) {
            const collections = {
                generator: 'generators',
                transformer: 'transformers',
                consumer: 'consumers',
                battery: 'batteries',
                h2_storage: 'h2_storage'
            };

            try {
                const res = await fetch(`${API_BASE}/api/nodes/${collections[nodeType]}/${name}`, {
                    method: 'DELETE'
                });
                const result = await res.json();

                if (result.status === 'ok') {
                    loadNodes();
                    showNodeStatus(`${nodeType} "${name}" deleted`, 'success');
                } else {
                    showNodeStatus('Error: ' + result.message, 'error');
                }
            } catch (e) {
                showNodeStatus('Error: ' + e.message, 'error');
            }
        }

        // Show status message
        function showNodeStatus(message, type) {
            const status = document.getElementById('node-status');
            status.className = 'status ' + type;
            status.textContent = message;
            setTimeout(() => { status.textContent = ''; status.className = ''; }, 3000);
        }

        // =========================================
        // Connection Management Functions
        // =========================================

        let connections = [];

        // Load connections from backend
        async function loadConnections() {
            try {
                const res = await fetch(`${API_BASE}/api/connections`);
                connections = await res.json();
                // Rebuild edges with connection info
                if (Object.keys(nodes).length > 0) {
                    rebuildNodesAndEdgesWithConnections();
                }
            } catch (e) {
                console.error('Failed to load connections:', e);
            }
        }

        // Toggle connection (kept for compatibility)
        async function toggleConnection(source, target, carrier) {
            try {
                const res = await fetch(`${API_BASE}/api/connections/toggle`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ source, target, carrier })
                });
                const result = await res.json();

                if (result.status === 'ok') {
                    // Update local state
                    const conn = connections.find(c =>
                        c.source === source && c.target === target && c.carrier === carrier
                    );
                    if (conn) conn.enabled = result.connection.enabled;
                    rebuildNodesAndEdgesWithConnections();
                    showNetworkStatus(result.message, 'success');
                } else {
                    showNetworkStatus('Error: ' + result.message, 'error');
                }
            } catch (e) {
                showNetworkStatus('Error: ' + e.message, 'error');
            }
        }

        // Delete connection (called when clicking on edge)
        async function deleteConnection(source, target, carrier) {
            try {
                const res = await fetch(`${API_BASE}/api/connections`, {
                    method: 'DELETE',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ source, target, carrier })
                });
                const result = await res.json();

                if (result.status === 'ok') {
                    // Remove from local state
                    const idx = connections.findIndex(c =>
                        c.source === source && c.target === target && c.carrier === carrier
                    );
                    if (idx >= 0) connections.splice(idx, 1);
                    rebuildNodesAndEdgesWithConnections();
                    showNetworkStatus(`Deleted: ${source} â†’ ${target}`, 'success');
                } else {
                    showNetworkStatus('Error: ' + result.message, 'error');
                }
            } catch (e) {
                showNetworkStatus('Error: ' + e.message, 'error');
            }
        }

        // Regenerate all connections
        async function regenerateConnections() {
            if (!confirm('This will regenerate all connections based on node types. Continue?')) return;

            try {
                const res = await fetch(`${API_BASE}/api/connections/regenerate`, { method: 'POST' });
                const result = await res.json();

                if (result.status === 'ok') {
                    connections = result.connections;
                    rebuildNodesAndEdgesWithConnections();
                    showNetworkStatus(result.message, 'success');
                } else {
                    showNetworkStatus('Error: ' + result.message, 'error');
                }
            } catch (e) {
                showNetworkStatus('Error: ' + e.message, 'error');
            }
        }

        // Rebuild nodes and edges using explicit connections
        // Preserves current positions for existing nodes
        function rebuildNodesAndEdgesWithConnections() {
            const oldNodes = { ...nodes };  // Save current positions
            nodes = {};
            edges.length = 0;

            // Helper to get position - prefer current position, then registry, then default
            function getNodePosition(name, registryPos, defaultPos) {
                if (oldNodes[name]) {
                    return { x: oldNodes[name].x, y: oldNodes[name].y };
                }
                const pos = registryPos || defaultPos;
                return {
                    x: (pos[0] + 3) / 6,
                    y: 1 - (pos[1] + 3) / 6
                };
            }

            // Add all nodes from registry
            nodeRegistry.generators.forEach((g, i) => {
                const pos = getNodePosition(g.name, g.position, [0, 2, 0]);
                nodes[g.name] = { ...pos, type: 'producer' };
            });

            nodeRegistry.transformers.forEach((t, i) => {
                const pos = getNodePosition(t.name, t.position, [-2, 0, 0]);
                nodes[t.name] = { ...pos, type: 'converter' };
            });

            nodeRegistry.consumers.forEach((c, i) => {
                const pos = getNodePosition(c.name, c.position, [0, -2, 0]);
                nodes[c.name] = { ...pos, type: 'consumer' };
            });

            (nodeRegistry.batteries || []).forEach((b, i) => {
                const pos = getNodePosition(b.name, b.position, [3, 0, 0]);
                nodes[b.name] = { ...pos, type: 'storage' };
            });

            (nodeRegistry.h2_storage || []).forEach((h, i) => {
                const pos = getNodePosition(h.name, h.position, [-3, -1, 0]);
                nodes[h.name] = { ...pos, type: 'storage' };
            });

            // Use connections (both enabled and disabled for visualization)
            connections.forEach(conn => {
                edges.push({
                    source: conn.source,
                    target: conn.target,
                    carrier: conn.carrier,
                    enabled: conn.enabled
                });
            });

            renderNetwork();
        }

        // =========================================
        // Zoom and Fullscreen Functions
        // =========================================

        let currentZoom = 1.0;
        let panX = 0;  // Pan offset in normalized coordinates
        let panY = 0;
        const minZoom = 0.25;
        const maxZoom = 4.0;
        const zoomStep = 0.25;

        function zoomIn() {
            zoomAtPoint(currentZoom + zoomStep, 0.5, 0.5);
        }

        function zoomOut() {
            zoomAtPoint(currentZoom - zoomStep, 0.5, 0.5);
        }

        // Zoom toward a specific point (in normalized 0-1 coordinates relative to canvas)
        function zoomAtPoint(newZoom, normMouseX, normMouseY) {
            newZoom = Math.max(minZoom, Math.min(maxZoom, newZoom));
            if (newZoom === currentZoom) return;

            // Convert mouse position from screen-normalized to world coordinates
            // Screen formula: screenNorm = (worldNorm - 0.5 - panX) * zoom + 0.5
            // So: worldNorm = (screenNorm - 0.5) / zoom + 0.5 + panX
            const worldX = (normMouseX - 0.5) / currentZoom + 0.5 + panX;
            const worldY = (normMouseY - 0.5) / currentZoom + 0.5 + panY;

            // After zoom change, we want the same world point under the mouse
            // New: screenNorm = (worldNorm - 0.5 - newPanX) * newZoom + 0.5
            // We want screenNorm to stay the same, so:
            // normMouseX = (worldX - 0.5 - newPanX) * newZoom + 0.5
            // Solve for newPanX:
            // newPanX = worldX - 0.5 - (normMouseX - 0.5) / newZoom
            panX = worldX - 0.5 - (normMouseX - 0.5) / newZoom;
            panY = worldY - 0.5 - (normMouseY - 0.5) / newZoom;

            currentZoom = newZoom;
            applyZoom();
        }

        function resetZoom() {
            currentZoom = 1.0;
            panX = 0;
            panY = 0;
            applyZoom();
        }

        function applyZoom() {
            const canvas = document.getElementById('network-canvas');

            // No CSS transforms - all handled by coordinate transformation in renderNetwork
            canvas.style.transform = 'none';

            document.getElementById('zoom-level').textContent = Math.round(currentZoom * 100) + '%';

            // Re-render with zoom-adjusted positions
            renderNetwork();
        }

        let isFullscreen = false;

        function toggleFullscreen() {
            const card = document.getElementById('network-card');
            isFullscreen = !isFullscreen;

            if (isFullscreen) {
                // Create overlay
                const overlay = document.createElement('div');
                overlay.className = 'fullscreen-overlay';
                overlay.id = 'fullscreen-overlay';
                document.body.appendChild(overlay);

                card.classList.add('fullscreen');
                document.body.style.overflow = 'hidden';
            } else {
                card.classList.remove('fullscreen');
                document.body.style.overflow = '';

                // Remove overlay
                const overlay = document.getElementById('fullscreen-overlay');
                if (overlay) overlay.remove();
            }

            // Re-render to adjust to new size
            setTimeout(renderNetwork, 100);
        }

        // Handle Escape key to exit fullscreen
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && isFullscreen) {
                toggleFullscreen();
            }
        });

        // Mouse wheel zoom - zooms toward mouse position
        // Middle-mouse button panning
        let isPanning = false;
        let panStartX = 0;
        let panStartY = 0;
        let panStartPanX = 0;
        let panStartPanY = 0;

        document.addEventListener('DOMContentLoaded', () => {
            const wrapper = document.getElementById('network-canvas-wrapper');

            // Wheel zoom
            wrapper.addEventListener('wheel', (e) => {
                if (e.ctrlKey) {
                    e.preventDefault();
                    const rect = wrapper.getBoundingClientRect();
                    // Calculate normalized mouse position (0-1) within the canvas
                    const normMouseX = (e.clientX - rect.left) / rect.width;
                    const normMouseY = (e.clientY - rect.top) / rect.height;

                    // Smoother zoom with smaller steps for wheel
                    const wheelZoomStep = 0.1;
                    const newZoom = e.deltaY < 0
                        ? currentZoom + wheelZoomStep
                        : currentZoom - wheelZoomStep;

                    zoomAtPoint(newZoom, normMouseX, normMouseY);
                }
            }, { passive: false });

            // Middle-mouse button pan (or right-click)
            wrapper.addEventListener('mousedown', (e) => {
                if (e.button === 1 || (e.button === 2 && e.shiftKey)) {  // Middle button or Shift+right-click
                    e.preventDefault();
                    isPanning = true;
                    panStartX = e.clientX;
                    panStartY = e.clientY;
                    panStartPanX = panX;
                    panStartPanY = panY;
                    wrapper.style.cursor = 'grabbing';
                }
            });

            document.addEventListener('mousemove', (e) => {
                if (!isPanning) return;
                const rect = wrapper.getBoundingClientRect();
                // Convert pixel delta to normalized coordinate delta
                const deltaX = (e.clientX - panStartX) / rect.width / currentZoom;
                const deltaY = (e.clientY - panStartY) / rect.height / currentZoom;
                panX = panStartPanX - deltaX;
                panY = panStartPanY - deltaY;
                renderNetwork();
            });

            document.addEventListener('mouseup', (e) => {
                if (isPanning) {
                    isPanning = false;
                    wrapper.style.cursor = '';
                }
            });

            // Prevent context menu on right-click in canvas
            wrapper.addEventListener('contextmenu', (e) => {
                if (e.shiftKey) {
                    e.preventDefault();
                }
            });
        });

        // =========================================
        // Save/Load Layout Functions
        // =========================================

        function saveLayout() {
            // Update positions in nodeRegistry from current visual state
            Object.entries(nodes).forEach(([name, node]) => {
                const pos = [(node.x * 6) - 3, ((1 - node.y) * 6) - 3, 0];
                // Find and update position in the appropriate category
                for (const cat of ['generators', 'transformers', 'consumers', 'batteries', 'h2_storage']) {
                    const item = (nodeRegistry[cat] || []).find(n => n.name === name);
                    if (item) {
                        item.position = pos;
                        break;
                    }
                }
            });

            // Build complete registry export with connections
            const exportData = {
                ...nodeRegistry,
                connections: connections
            };

            // Create and download file
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `node-registry-${new Date().toISOString().slice(0,10)}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showNetworkStatus('Node registry saved!', 'success');
        }

        function loadLayoutFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const data = JSON.parse(e.target.result);

                    // Check if this is a full registry (has generators/transformers/consumers)
                    // or legacy positions-only format
                    if (data.generators || data.transformers || data.consumers) {
                        // Full registry format - update everything
                        nodeRegistry = {
                            generators: data.generators || [],
                            transformers: data.transformers || [],
                            consumers: data.consumers || [],
                            batteries: data.batteries || [],
                            h2_storage: data.h2_storage || []
                        };

                        if (data.connections) {
                            connections = data.connections;
                        }

                        // Save to server
                        await fetch(`${API_BASE}/api/nodes`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(nodeRegistry)
                        });

                        if (data.connections) {
                            await fetch(`${API_BASE}/api/connections`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify(connections)
                            });
                        }

                        // Rebuild UI
                        renderNodeLists();
                        renderConsumerUtilityForms();
                        rebuildNodesAndEdgesWithConnections();
                        renderNetwork();
                        renderConnectionsList();

                        const nodeCount = nodeRegistry.generators.length +
                                         nodeRegistry.transformers.length +
                                         nodeRegistry.consumers.length +
                                         (nodeRegistry.batteries || []).length +
                                         (nodeRegistry.h2_storage || []).length;
                        showNetworkStatus(`Loaded registry: ${nodeCount} nodes, ${connections.length} connections`, 'success');
                    } else {
                        // Legacy positions-only format
                        const positions = data.positions || data;
                        Object.entries(positions).forEach(([name, pos]) => {
                            if (nodes[name] && Array.isArray(pos)) {
                                nodes[name].x = (pos[0] + 3) / 6;
                                nodes[name].y = 1 - (pos[1] + 3) / 6;
                            }
                        });
                        await updateNetworkPositions();
                        renderNetwork();
                        showNetworkStatus(`Loaded layout with ${Object.keys(positions).length} positions`, 'success');
                    }
                } catch (err) {
                    showNetworkStatus('Error loading registry: ' + err.message, 'error');
                }

                // Reset file input
                event.target.value = '';
            };
            reader.readAsText(file);
        }

        function showNetworkStatus(message, type) {
            const status = document.getElementById('network-status');
            status.className = 'status ' + type;
            status.textContent = message;
            setTimeout(() => { status.textContent = ''; status.className = ''; }, 3000);
        }

        // Update initialization to load nodes and connections
        document.addEventListener('DOMContentLoaded', () => {
            loadConfig();
            loadPresetList();
            loadNodes();
            loadConnections();
            renderNetwork();
        });
    </script>
</body>
</html>
