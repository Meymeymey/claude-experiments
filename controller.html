<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hydrogen Simulation Controller</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #eee;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
            color: #4ecca3;
            font-size: 2rem;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
        }

        .card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .card h2 {
            color: #4ecca3;
            margin-bottom: 15px;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .card h2 .icon {
            font-size: 1.4rem;
        }

        /* Parameter inputs */
        .param-group {
            margin-bottom: 15px;
        }

        .param-group label {
            display: block;
            margin-bottom: 5px;
            color: #aaa;
            font-size: 0.9rem;
        }

        .param-group input {
            width: 100%;
            padding: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.3);
            color: #fff;
            font-size: 1rem;
        }

        .param-group input:focus {
            outline: none;
            border-color: #4ecca3;
        }

        .param-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        /* Buttons */
        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: 6px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            justify-content: center;
        }

        .btn-primary {
            background: #4ecca3;
            color: #1a1a2e;
            font-weight: 600;
        }

        .btn-primary:hover {
            background: #3db892;
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .btn-blender {
            background: #ea7600;
            color: #fff;
        }

        .btn-blender:hover {
            background: #ff8c1a;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .btn-group .btn {
            flex: 1;
        }

        /* Network visualization */
        .network-canvas {
            width: 100%;
            height: 250px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            position: relative;
            overflow: hidden;
        }

        .node {
            position: absolute;
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.8rem;
            cursor: move;
            transition: transform 0.1s;
        }

        .node.producer {
            clip-path: polygon(50% 0%, 0% 100%, 100% 100%);
            background: #4ecca3;
            color: #1a1a2e;
        }

        .node.converter {
            background: #f0c040;
            color: #1a1a2e;
            border-radius: 4px;
        }

        .node.consumer {
            background: #e74c3c;
            color: #fff;
            border-radius: 50%;
        }

        .node:hover {
            transform: scale(1.1);
        }

        .pipe {
            position: absolute;
            height: 4px;
            transform-origin: left center;
            pointer-events: none;
        }

        .pipe.electricity {
            background: linear-gradient(90deg, #f0c040, #ffd700);
        }

        .pipe.hydrogen {
            background: linear-gradient(90deg, #3498db, #5dade2);
        }

        /* Results */
        .results-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .result-item {
            background: rgba(0, 0, 0, 0.2);
            padding: 12px;
            border-radius: 6px;
        }

        .result-item .label {
            font-size: 0.8rem;
            color: #888;
            margin-bottom: 4px;
        }

        .result-item .value {
            font-size: 1.3rem;
            font-weight: bold;
            color: #4ecca3;
        }

        /* Status */
        .status {
            padding: 10px;
            border-radius: 6px;
            margin-top: 15px;
            font-size: 0.9rem;
        }

        .status.success {
            background: rgba(78, 204, 163, 0.2);
            border: 1px solid #4ecca3;
        }

        .status.error {
            background: rgba(231, 76, 60, 0.2);
            border: 1px solid #e74c3c;
        }

        .status.info {
            background: rgba(52, 152, 219, 0.2);
            border: 1px solid #3498db;
        }

        /* Loading spinner */
        .spinner {
            width: 20px;
            height: 20px;
            border: 2px solid transparent;
            border-top-color: currentColor;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Footer */
        .footer {
            text-align: center;
            margin-top: 30px;
            color: #666;
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Hydrogen Simulation Controller</h1>

        <div class="grid">
            <!-- Parameters Card -->
            <div class="card">
                <h2><span class="icon">âš¡</span> Simulation Parameters</h2>

                <div class="param-group">
                    <label>Simulation Periods (hours)</label>
                    <input type="number" id="periods" value="24" min="1" max="168">
                </div>

                <div class="param-row">
                    <div class="param-group">
                        <label>Alpha Capacity (kW)</label>
                        <input type="number" id="alpha_capacity" value="100" min="0" step="10">
                    </div>
                    <div class="param-group">
                        <label>Delta Demand (kW)</label>
                        <input type="number" id="delta_demand" value="30" min="0" step="5">
                    </div>
                </div>

                <div class="param-row">
                    <div class="param-group">
                        <label>Bravo Capacity (kW)</label>
                        <input type="number" id="bravo_capacity" value="50" min="0" step="10">
                    </div>
                    <div class="param-group">
                        <label>Bravo Efficiency (%)</label>
                        <input type="number" id="bravo_efficiency" value="70" min="0" max="100" step="5">
                    </div>
                </div>

                <div class="param-group">
                    <label>Charlie Hâ‚‚ Demand (kg/h)</label>
                    <input type="number" id="charlie_demand" value="10" min="0" step="1">
                </div>

                <div class="btn-group">
                    <button class="btn btn-primary" onclick="runSimulation()">
                        <span id="sim-icon">â–¶</span> Run Simulation
                    </button>
                </div>

                <div id="sim-status"></div>
            </div>

            <!-- Results Card -->
            <div class="card">
                <h2><span class="icon">ðŸ“Š</span> Simulation Results</h2>

                <div class="results-grid">
                    <div class="result-item">
                        <div class="label">Electricity Produced</div>
                        <div class="value" id="res-elec-produced">--</div>
                    </div>
                    <div class="result-item">
                        <div class="label">To Electrolyzer</div>
                        <div class="value" id="res-to-electrolyzer">--</div>
                    </div>
                    <div class="result-item">
                        <div class="label">Hâ‚‚ Produced</div>
                        <div class="value" id="res-h2-consumed">--</div>
                    </div>
                    <div class="result-item">
                        <div class="label">Elec Consumed</div>
                        <div class="value" id="res-elec-consumed">--</div>
                    </div>
                </div>

                <div id="results-status"></div>
            </div>

            <!-- Network Card -->
            <div class="card">
                <h2><span class="icon">ðŸ”—</span> Network Topology</h2>

                <div class="network-canvas" id="network-canvas">
                    <!-- Pipes will be drawn here -->
                    <svg id="pipes-svg" style="position:absolute;width:100%;height:100%;pointer-events:none;"></svg>
                    <!-- Nodes will be positioned here -->
                </div>

                <div id="network-status"></div>
            </div>

            <!-- Blender Card -->
            <div class="card">
                <h2><span class="icon">ðŸŽ¨</span> Blender Integration</h2>

                <p style="color: #888; margin-bottom: 15px; font-size: 0.9rem;">
                    Sync node positions between this controller and Blender.
                </p>

                <div class="btn-group">
                    <button class="btn btn-blender" onclick="launchBlender()">
                        ðŸš€ Launch Blender
                    </button>
                </div>

                <div class="btn-group">
                    <button class="btn btn-secondary" onclick="exportToBlender()">
                        ðŸ“¤ Export to Blender
                    </button>
                    <button class="btn btn-secondary" onclick="syncFromBlender()">
                        ðŸ“¥ Sync from Blender
                    </button>
                </div>

                <div id="blender-status"></div>

                <div style="margin-top: 15px; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 6px; font-size: 0.85rem; color: #888;">
                    <strong>In Blender console:</strong><br>
                    <code style="color: #4ecca3;">sync_from_blender()</code>
                </div>
            </div>
        </div>

        <div class="footer">
            Hydrogen System Simulation | NetworkX + oemof + Blender
        </div>
    </div>

    <script>
        const API_BASE = '';

        // Node positions (normalized 0-1)
        let nodes = {
            'Alpha': { x: 0.5, y: 0.1, type: 'producer' },
            'Bravo': { x: 0.25, y: 0.5, type: 'converter' },
            'Charlie': { x: 0.25, y: 0.85, type: 'consumer' },
            'Delta': { x: 0.75, y: 0.5, type: 'consumer' }
        };

        const edges = [
            { source: 'Alpha', target: 'Bravo', carrier: 'electricity' },
            { source: 'Alpha', target: 'Delta', carrier: 'electricity' },
            { source: 'Bravo', target: 'Charlie', carrier: 'hydrogen' }
        ];

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            loadConfig();
            loadNetwork();
            renderNetwork();
        });

        // Load configuration
        async function loadConfig() {
            try {
                const res = await fetch(`${API_BASE}/api/config`);
                const config = await res.json();

                document.getElementById('periods').value = config.periods;
                document.getElementById('alpha_capacity').value = config.alpha_capacity;
                document.getElementById('bravo_capacity').value = config.bravo_capacity;
                document.getElementById('bravo_efficiency').value = config.bravo_efficiency * 100;
                document.getElementById('charlie_demand').value = config.charlie_demand;
                document.getElementById('delta_demand').value = config.delta_demand;
            } catch (e) {
                console.error('Failed to load config:', e);
            }
        }

        // Load network
        async function loadNetwork() {
            try {
                const res = await fetch(`${API_BASE}/api/network`);
                const network = await res.json();

                if (network.nodes) {
                    // Convert 3D positions to 2D canvas positions
                    const canvas = document.getElementById('network-canvas');
                    const rect = canvas.getBoundingClientRect();

                    network.nodes.forEach(node => {
                        if (nodes[node.name]) {
                            // Map from coordinate space to 0-1
                            // Assuming x: -3 to 3, y: -3 to 3
                            nodes[node.name].x = (node.position[0] + 3) / 6;
                            nodes[node.name].y = 1 - (node.position[1] + 3) / 6; // Flip Y
                        }
                    });

                    renderNetwork();
                }
            } catch (e) {
                console.error('Failed to load network:', e);
            }
        }

        // Render network visualization
        function renderNetwork() {
            const canvas = document.getElementById('network-canvas');
            const svg = document.getElementById('pipes-svg');
            const rect = canvas.getBoundingClientRect();

            // Clear existing nodes (keep SVG)
            canvas.querySelectorAll('.node').forEach(n => n.remove());
            svg.innerHTML = '';

            // Draw pipes first
            edges.forEach(edge => {
                const source = nodes[edge.source];
                const target = nodes[edge.target];

                const x1 = source.x * rect.width;
                const y1 = source.y * rect.height;
                const x2 = target.x * rect.width;
                const y2 = target.y * rect.height;

                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', x1);
                line.setAttribute('y1', y1);
                line.setAttribute('x2', x2);
                line.setAttribute('y2', y2);
                line.setAttribute('stroke', edge.carrier === 'electricity' ? '#f0c040' : '#3498db');
                line.setAttribute('stroke-width', '4');
                line.setAttribute('stroke-linecap', 'round');
                svg.appendChild(line);
            });

            // Draw nodes
            Object.entries(nodes).forEach(([name, node]) => {
                const el = document.createElement('div');
                el.className = `node ${node.type}`;
                el.textContent = name;
                el.style.left = `${node.x * rect.width - 30}px`;
                el.style.top = `${node.y * rect.height - 30}px`;

                // Make draggable
                el.addEventListener('mousedown', startDrag);
                el.dataset.name = name;

                canvas.appendChild(el);
            });
        }

        // Drag functionality
        let dragging = null;
        let dragOffset = { x: 0, y: 0 };

        function startDrag(e) {
            dragging = e.target;
            const rect = dragging.getBoundingClientRect();
            dragOffset.x = e.clientX - rect.left - 30;
            dragOffset.y = e.clientY - rect.top - 30;

            document.addEventListener('mousemove', doDrag);
            document.addEventListener('mouseup', stopDrag);
        }

        function doDrag(e) {
            if (!dragging) return;

            const canvas = document.getElementById('network-canvas');
            const rect = canvas.getBoundingClientRect();

            let x = (e.clientX - rect.left - dragOffset.x) / rect.width;
            let y = (e.clientY - rect.top - dragOffset.y) / rect.height;

            // Clamp
            x = Math.max(0.1, Math.min(0.9, x));
            y = Math.max(0.1, Math.min(0.9, y));

            const name = dragging.dataset.name;
            nodes[name].x = x;
            nodes[name].y = y;

            renderNetwork();
        }

        function stopDrag() {
            if (dragging) {
                updateNetworkPositions();
            }
            dragging = null;
            document.removeEventListener('mousemove', doDrag);
            document.removeEventListener('mouseup', stopDrag);
        }

        // Update network positions on server
        async function updateNetworkPositions() {
            const networkNodes = Object.entries(nodes).map(([name, node]) => ({
                name,
                node_type: node.type,
                carrier: node.type === 'producer' ? 'electricity' :
                         node.type === 'converter' ? 'both' : 'hydrogen',
                position: [
                    (node.x * 6) - 3,  // Convert back to coordinate space
                    ((1 - node.y) * 6) - 3,  // Flip Y back
                    0
                ]
            }));

            try {
                await fetch(`${API_BASE}/api/network`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ nodes: networkNodes })
                });
            } catch (e) {
                console.error('Failed to update network:', e);
            }
        }

        // Run simulation
        async function runSimulation() {
            const btn = document.querySelector('[onclick="runSimulation()"]');
            const icon = document.getElementById('sim-icon');
            const status = document.getElementById('sim-status');

            btn.disabled = true;
            icon.innerHTML = '<div class="spinner"></div>';

            // Update config first
            const config = {
                periods: parseInt(document.getElementById('periods').value),
                alpha_capacity: parseFloat(document.getElementById('alpha_capacity').value),
                bravo_capacity: parseFloat(document.getElementById('bravo_capacity').value),
                bravo_efficiency: parseFloat(document.getElementById('bravo_efficiency').value) / 100,
                charlie_demand: parseFloat(document.getElementById('charlie_demand').value),
                delta_demand: parseFloat(document.getElementById('delta_demand').value)
            };

            try {
                await fetch(`${API_BASE}/api/config`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(config)
                });

                const res = await fetch(`${API_BASE}/api/simulate`, { method: 'POST' });
                const data = await res.json();

                if (data.status === 'ok') {
                    status.className = 'status success';
                    status.textContent = 'Simulation completed successfully!';

                    // Update results
                    const s = data.summary;
                    document.getElementById('res-elec-produced').textContent =
                        (s.total_electricity_produced || 0).toFixed(1) + ' kWh';
                    document.getElementById('res-to-electrolyzer').textContent =
                        (s.total_electricity_to_hydrogen || 0).toFixed(1) + ' kWh';
                    document.getElementById('res-h2-consumed').textContent =
                        (s.total_hydrogen_consumed || 0).toFixed(1) + ' kg';
                    document.getElementById('res-elec-consumed').textContent =
                        (s.total_electricity_consumed || 0).toFixed(1) + ' kWh';
                } else {
                    throw new Error(data.message);
                }
            } catch (e) {
                status.className = 'status error';
                status.textContent = 'Error: ' + e.message;
            }

            btn.disabled = false;
            icon.textContent = 'â–¶';
        }

        // Blender functions
        async function launchBlender() {
            const status = document.getElementById('blender-status');
            try {
                const res = await fetch(`${API_BASE}/api/blender/launch`, { method: 'POST' });
                const data = await res.json();

                status.className = 'status ' + (data.status === 'ok' ? 'success' : 'info');
                status.textContent = data.message;
            } catch (e) {
                status.className = 'status error';
                status.textContent = 'Error: ' + e.message;
            }
        }

        async function exportToBlender() {
            const status = document.getElementById('blender-status');
            try {
                const res = await fetch(`${API_BASE}/api/blender/export`, { method: 'POST' });
                const data = await res.json();

                status.className = 'status ' + (data.status === 'ok' ? 'success' : 'error');
                status.textContent = data.message;
            } catch (e) {
                status.className = 'status error';
                status.textContent = 'Error: ' + e.message;
            }
        }

        async function syncFromBlender() {
            const status = document.getElementById('blender-status');
            try {
                const res = await fetch(`${API_BASE}/api/blender/sync`, { method: 'POST' });
                const data = await res.json();

                if (data.status === 'ok') {
                    status.className = 'status success';
                    status.textContent = 'Synced from Blender!';
                    loadNetwork();
                } else {
                    throw new Error(data.message);
                }
            } catch (e) {
                status.className = 'status error';
                status.textContent = 'Error: ' + e.message;
            }
        }

        // Resize handler
        window.addEventListener('resize', renderNetwork);
    </script>
</body>
</html>
